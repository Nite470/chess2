<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess 2: Economy Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <script>
        const GEMINI_API_KEY = 'AIzaSyDuQ89DuJCXx9kJoS7qFDWaiNqSYf6l1jI';

        let socket;
        let currentRoomId = null;
        let myOnlineColor = null;
        let isConnected = false;

        function connectToServer() {
            const btn = document.getElementById('btn-connect');
            if (btn) {
                btn.innerText = "Подключение...";
                btn.disabled = true;
            }
            socket = io();
            socket.on('connect', () => {
                isConnected = true;
                document.getElementById('online-status').innerText = "СЕРВЕР: ПОДКЛЮЧЕН";
                document.getElementById('online-status').classList.replace('text-gray-500', 'text-emerald-400');
                if (btn) btn.innerText = "OK";
                const connPanel = document.getElementById('connection-panel');
                if (connPanel) connPanel.classList.add('hidden');
                document.getElementById('lobby-panel').classList.remove('hidden');
            });
            setupSocketListeners();
        }

        window.onload = () => {
            connectToServer();
        };

        function setupSocketListeners() {
            socket.on('room_list', (rooms) => {
                const listEl = document.getElementById('room-list-container');
                listEl.innerHTML = '';
                if (rooms.length === 0) {
                    listEl.innerHTML = '<div class="text-gray-500 text-[10px] italic">Нет доступных комнат</div>';
                    return;
                }
                rooms.forEach(room => {
                    const roomBtn = document.createElement('button');
                    roomBtn.className = "w-full text-left bg-slate-800 hover:bg-slate-700 border border-slate-600 p-2 mb-1 rounded text-xs flex justify-between items-center group transition-all";
                    roomBtn.onclick = () => {
                        document.getElementById('room-input').value = room.id;
                        joinGame();
                    };
                    roomBtn.innerHTML = `
                <span class="text-blue-400 font-mono font-bold group-hover:text-blue-300">#${room.id}</span>
                <span class="text-gray-400 text-[9px]">Игроков: ${room.count}/2</span>
            `;
                    listEl.appendChild(roomBtn);
                });
            });

            socket.on('player_joined', (data) => {
                log(`Игрок подключился! Комната: ${data.roomId}`);
                document.getElementById('online-msg').innerText = "Соперник в игре!";
            });

            socket.on('game_start', (data) => {
                myOnlineColor = data.color;
                currentRoomId = data.roomId;
                moveCount = 0; 
                
                // Применяем данные сразу
                if(data.economy) economy = data.economy;
                if(data.graveyard) graveyard = data.graveyard;
                if(data.resHist) resHist = data.resHist;
                if(data.chimeraTracker) chimeraTracker = data.chimeraTracker;

                window.syncBoardFromOnline(data.board, data.turn, data.castling);
                window.enterOnlineMode(data.roomId, `Вы играете за: ${myOnlineColor === 'white' ? 'БЕЛЫХ' : 'ЧЕРНЫХ'}`);
                log(`Игра началась! Ваш цвет: ${myOnlineColor.toUpperCase()}`);
            });

            socket.on('receive_move', (data) => {
                if (typeof data.moveCount !== 'undefined') moveCount = data.moveCount;
                if (data.mode) gameMode = data.mode;
                if (data.mode === 'new_mode') {
                    kingDead = true;
                    newModePlayer = data.turn;
                }

                // Обновляем экономику
                if(data.economy) economy = data.economy;
                if(data.graveyard) graveyard = data.graveyard;
                if(data.resHist) resHist = data.resHist;
                if(data.chimeraTracker) chimeraTracker = data.chimeraTracker;

                document.getElementById('dip-modal').classList.remove('active');

                if (data.lastMove && data.lastMove.proposal) {
                    if (myOnlineColor && myOnlineColor === data.turn) {
                        log("Ожидание ответа соперника на союз...");
                    } else {
                        pendingMove = data.lastMove.to;
                        selected = data.lastMove.from;
                        document.getElementById('dip-modal').classList.add('active');
                        log("Получено предложение союза!");
                    }
                } else {
                    window.syncBoardFromOnline(data.board, data.turn, data.castling);
                    lastMoveData = data.lastMove || null;
                    render();
                    updateUI();
                    checkGameState();
                }
            });

            socket.on('error_msg', (msg) => alert(msg));
            socket.on('opponent_left', () => { 
                alert("Соперник отключился."); 
                // Не перезагружаем страницу принудительно, чтобы не терять лог, но можно сделать рестарт
                location.reload(); 
            });
        }

        window.hostGame = () => {
            if (!isConnected) return alert("Сначала подключитесь к серверу!");
            const roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
            socket.emit('create_room', roomId);
            window.enterOnlineMode(roomId, "Ожидание соперника...");
        };

        window.joinGame = () => {
            if (!isConnected) return alert("Сначала подключитесь к серверу!");
            const roomId = document.getElementById('room-input').value.toUpperCase();
            if (!roomId) return alert("Введите ID комнаты");
            socket.emit('join_room', roomId);
        };

        window.enterOnlineMode = (id, status) => {
            document.getElementById('lobby-panel').classList.add('hidden');
            document.getElementById('online-active-ui').classList.remove('hidden');
            document.getElementById('room-display').innerText = id;
            document.getElementById('online-msg').innerText = status;
        };

        window.sendMoveToCloud = (boardState, nextTurn, moveDetails, castlingState, modeState, mCount) => {
            if (!socket || !currentRoomId) return;
            socket.emit('make_move', {
                roomId: currentRoomId,
                board: boardState,
                turn: nextTurn,
                lastMove: moveDetails,
                castling: castlingState,
                mode: modeState || gameMode,
                moveCount: mCount,
                // ОТПРАВЛЯЕМ ВСЮ ЭКОНОМИКУ
                chimeraTracker: chimeraTracker,
                economy: economy,
                graveyard: graveyard,
                resHist: resHist
            });
        };

        window.getOnlineColor = () => myOnlineColor;
        window.isOnlineActive = () => !!currentRoomId;
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --bg: #0f172a;
            --dark: #1e293b;
            --light: #475569;
            --gold: #fbbf24;
            --blue: #3b82f6;
            --purp: #d946ef;
            --red: #ef4444;
            --orange: #a3d4e8;
            --fiol: #1c7094;
            --background: linear-gradient(180deg, #0e0030, #00111d);
        }

        body {
            background: linear-gradient(180deg, #120038, #001526);
            color: #e2e8f0;
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            user-select: none;
        }

        .title-font {
            font-family: 'Orbitron', sans-serif;
        }

        .board-wrapper {
            width: 100%;
            max-width: 80vh;
            aspect-ratio: 1;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 8px solid #334155;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            position: relative; 
            transition: transform 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55); 
        }
        @keyframes glowPurple {
            0% { stroke-opacity: 1; filter: drop-shadow(0 0 6px rgba(170, 80, 247, 0.8)); }
            50% { stroke-opacity: 0.4; filter: drop-shadow(0 0 14px rgba(170, 80, 247, 1)); }
            100% { stroke-opacity: 1; filter: drop-shadow(0 0 6px rgba(170, 80, 255, 0.8)); }
        }

        .last-move-purple { animation: glowPurple 1.2s infinite ease-in-out; }
        .board-wrapper.flipped { transform: rotate(180deg); }
        .board-wrapper.flipped .cell { transform: rotate(180deg); }

        .cell {
            display: flex; justify-content: center; align-items: center;
            font-size: clamp(1rem, 5vmin, 4rem); cursor: pointer;
            position: relative; overflow: hidden; transition: transform 0.8s;
        }
        .cell.light { background: var(--orange); color: #cbd5e0; }
        .cell.dark { background: var(--fiol); color: #94a3b8; }
        .cell.selected { background: rgba(251, 191, 36, 0.3) !important; box-shadow: inset 0 0 10px var(--gold); }
        .cell.check { background: rgba(239, 68, 68, 0.6) !important; }
        .cell.place-mode { background: rgba(16, 185, 129, 0.3) !important; box-shadow: inset 0 0 10px #10b981; }
        .cell.allowed-zone { background: rgba(59, 130, 246, 0.2) !important; box-shadow: inset 0 0 10px #3b82f6; }

        .hint {
            position: absolute; pointer-events: none; z-index: 20;
            width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;
        }
        .move-hint::after { content: ''; width: 20%; height: 20%; background: rgba(16, 185, 129, 0.6); border-radius: 50%; }
        .attack-hint { border: 4px solid rgba(239, 68, 68, 0.6); }
        .union-hint { border: 4px solid var(--purp); box-shadow: inset 0 0 15px var(--purp); }

        #svg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 15; }

        .special-hint { font-size: 0.6em; font-weight: bold; border: 2px solid; background: rgba(0,0,0,0.5); padding: 2px 4px; border-radius: 4px; }
        .special-hint.fuse { border-color: var(--gold); color: var(--gold); }
        .special-hint.legion { border-color: var(--blue); color: var(--blue); }
        .special-hint.union { border-color: var(--purp); color: var(--purp); }
        .special-hint.castle { border-color: rgb(255, 146, 3); color: white; }

        .piece {
            z-index: 10; filter: drop-shadow(0 4px 2px rgba(0,0,0,0.5));
            max-width: 90%; max-height: 90%; line-height: 1; transition: transform 0.2s;
        }
        .piece:hover { transform: scale(1.1); }
        .piece.white { color: #f8fafc; text-shadow: -1px -1px 1px rgba(0,0,0,0.5), 1px -1px 1px rgba(0,0,0,0.5), -1px 1px 1px rgba(0,0,0,0.5), 1px 1px 1px rgba(0,0,0,0.5), 0px 0px 4px rgba(0,0,0,0.6); }
        .piece.black { color: #0a0a0a; text-shadow: 0 0 2px white, 0 0 4px rgba(255,255,255,0.8), 0 0 6px rgba(0,0,0,0.5); }
        .piece.archon { color: var(--gold) !important; filter: drop-shadow(0 0 10px var(--gold)); }
        .piece.legion { color: #ff7c00 !important; text-shadow: -1px -1px 1px rgba(0,0,0,0.65), 1px -1px 1px rgba(0,0,0,0.65), -1px 1px 1px rgba(0,0,0,0.65), 1px 1px 1px rgba(0,0,0,0.65), 0px 0px 6px rgba(59,130,246,0.85), 0px 0px 10px rgba(59,130,246,0.55); filter: none; }
        .piece.chimera { color: var(--purp) !important; filter: drop-shadow(0 0 10px var(--purp)); animation: pulse 2s infinite; }
        .piece.heavy { color: #f43f5e !important; filter: drop-shadow(0 0 10px #f43f5e); }
        @keyframes pulse { 0%,100% { filter: drop-shadow(0 0 5px var(--purp)); } 50% { filter: drop-shadow(0 0 15px var(--purp)); } }
        .badge { position: absolute; bottom: 1px; right: 1px; font-size: 0.4em; pointer-events: none; font-family: sans-serif; font-weight: bold; }

        .btn { background: #1e293b; border: 1px solid #475569; padding: 10px; color: white; width: 100%; margin-bottom: 5px; cursor: pointer; transition: 0.2s; font-weight: bold; text-transform: uppercase; font-size: 0.8rem; }
        .btn:hover { background: #334155; border-color: white; }
        .btn-primary { background: #1d4ed8; border-color: #3b82f6; }
        .btn-danger { background: #b91c1c; border-color: #ef4444; }

        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 50; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal.active { display: flex; }

        .stat-box { background: #1e293b; padding: 10px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #334155; }
        input.dark-input { background: #0f172a; border: 1px solid #334155; color: white; padding: 8px; width: 100%; font-family: monospace; }
        .piece.archon-light { color: #f6d24a !important; text-shadow: -1px -1px 1px rgba(0,0,0,0.4), 1px -1px 1px rgba(0,0,0,0.4), -1px 1px 1px rgba(0,0,0,0.4), 1px 1px 1px rgba(0,0,0,0.4), 0px 0px 6px rgba(255,215,0,0.7); filter: none; }
        .piece.archon-dark { color: #cc3fd3 !important; text-shadow: -1px -1px 1px rgba(0,0,0,0.5), 1px -1px 1px rgba(0,0,0,0.5), -1px 1px 1px rgba(0,0,0,0.5), 1px 1px 1px rgba(0,0,0,0.5), 0px 0px 6px rgba(66,196,232,0.8); filter: none; }

        .shop-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 4px 8px; background: #0f172a; border: 1px solid #334155;
            margin-bottom: 4px; cursor: pointer; border-radius: 4px; transition: 0.2s;
        }
        .shop-item:hover { background: #1e293b; border-color: #fbbf24; }
        .shop-item.active { background: #3b82f6; border-color: white; color: white; }
        .coin-icon { color: #fbbf24; margin-right: 4px; }
        .shop-piece { font-size: 1.2em; }

        @media (max-width: 700px) {
            body { overflow: auto; }
            .w-full.md\:w-80 { width: 100% !important; max-height: 35vh; overflow-y: auto; }
            .flex-1 { height: 65vh !important; padding: 0 !important; }
            .board-wrapper { max-width: 95vw !important; width: 95vw !important; height: 95vw !important; aspect-ratio: 1 !important; }
            .cell { font-size: 6vw !important; }
            .piece { max-width: 85% !important; max-height: 85% !important; }
            #log { max-height: 150px; }
        }
    </style>
</head>
<body class="flex flex-col md:flex-row h-screen">

    <!-- Sidebar -->
    <div class="w-full md:w-80 bg-[#020617] p-6 border-r border-[#1e293b] flex flex-col z-20 shadow-2xl overflow-y-auto">
        <h1 class="text-3xl font-bold title-font mb-1 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">ШАХМАТЫ 2.0</h1>
        <div class="text-xs text-gray-500 mb-6 font-mono">ECONOMY Edition</div>

        <!-- ЭКОНОМИКА БЛОК -->
        <div class="stat-box">
            <div class="flex justify-between items-center mb-2">
                <span class="text-xs text-gray-400">ХОД</span>
                <span id="turn-display" class="font-bold text-white bg-slate-700 px-2 py-1 rounded">БЕЛЫЕ</span>
            </div>
            <div class="flex justify-between items-center border-t border-gray-700 pt-2">
                <div class="text-xs text-white"><i class="fas fa-coins text-yellow-500 mr-1"></i>Белые: <span id="coin-w" class="font-bold">0</span></div>
                <div class="text-xs text-white"><i class="fas fa-coins text-yellow-500 mr-1"></i>Черные: <span id="coin-b" class="font-bold">0</span></div>
            </div>
            <div class="text-[10px] text-gray-500 flex justify-between mt-1">
                <span>Режим: <span id="mode-display" class="text-blue-400">КЛАССИКА</span></span>
                <span>Лояльность: <span id="loyalty" class="text-white">3</span></span>
            </div>
        </div>

        <!-- МАГАЗИН ВОСКРЕШЕНИЯ -->
        <div class="stat-box">
            <div class="text-[10px] text-gray-400 mb-2 uppercase font-bold tracking-wider">Кладбище (Магазин)</div>
            <div id="graveyard-list" class="max-h-[150px] overflow-y-auto pr-1">
                <div class="text-gray-500 text-xs italic">Пусто...</div>
            </div>
            <div class="text-[9px] text-gray-500 mt-2 text-center">
                Лимит: 1 воскрешение за 3 хода.<br>Белые: 7-8 ряд, Черные: 1-2 ряд.
            </div>
            <button id="cancel-shop-btn" class="btn btn-danger text-xs mt-2 hidden" onclick="cancelShop()">Отмена выбора</button>
        </div>

        <div class="stat-box">
            <div class="text-[10px] text-gray-400 flex justify-between mt-1 mb-2">
                <span>Мораль Белых: <span id="morale-w" class="text-emerald-400">10</span></span>
                <span>Мораль Черных: <span id="morale-b" class="text-emerald-400">10</span></span>
            </div>
            <div id="online-status" class="text-[10px] text-gray-500 mb-2 font-bold">СЕТЬ: НЕ ПОДКЛЮЧЕНА</div>
            <div id="connection-panel" class="mb-4 pb-4 border-b border-gray-700">
                <button id="btn-connect" onclick="connectToServer()" class="btn btn-primary text-xs">Подключиться к Серверу</button>
            </div>
            <div id="lobby-panel" class="hidden">
                <button onclick="hostGame()" class="btn btn-primary mb-2">Создать Комнату</button>
                <div class="flex gap-2 mb-3">
                    <input id="room-input" type="text" placeholder="ID" class="w-2/3 bg-slate-900 border border-slate-600 px-3 text-white uppercase outline-none text-sm rounded">
                    <button onclick="joinGame()" class="w-1/3 btn text-xs py-2 m-0">Войти</button>
                </div>
                <div class="border-t border-gray-700 pt-2">
                    <div class="text-[10px] text-gray-400 mb-1">Доступные комнаты:</div>
                    <div id="room-list-container" class="max-h-[100px] overflow-y-auto">
                        <div class="text-gray-500 text-[10px] italic">Ожидание данных...</div>
                    </div>
                </div>
            </div>
            <div id="online-active-ui" class="hidden text-center">
                <div id="room-display" class="text-2xl font-mono text-green-400 border border-green-900 p-2 bg-black select-all mb-1 rounded tracking-widest">---</div>
                <div id="online-msg" class="text-[10px] text-gray-400">Ожидание...</div>
            </div>
        </div>

        <div class="stat-box text-xs">
            <div class="flex justify-between mb-1">
                <span class="text-gray-400">Потери Белых</span>
                <span id="loss-w" class="text-red-400 font-bold text-lg">0</span>
            </div>
            <div class="flex justify-between">
                <span class="text-gray-400">Потери Черных</span>
                <span id="loss-b" class="text-red-400 font-bold text-lg">0</span>
            </div>
        </div>
        <div id="log" class="flex-1 bg-black p-3 font-mono text-[10px] text-green-500 overflow-y-auto border border-gray-800 rounded min-h-[100px] leading-relaxed">
            <div>> Экономика подключена.</div>
        </div>
        <button onclick="location.reload()" class="btn mt-4 bg-slate-800">Перезагрузка</button>
        <button onclick="toggleAI()" class="btn bg-purple-700 mt-2">ИГРАТЬ С ИИ</button>

    </div>

    <div class="flex-1 flex items-center justify-center p-4 relative overflow-hidden">
        <div class="absolute inset-0 opacity-10 bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-blue-900 via-gray-900 to-black pointer-events-none"></div>
        <div id="board" class="board-wrapper shadow-2xl relative z-10">
            <svg id="svg-overlay" width="100%" height="100%"></svg>
        </div>
    </div>

    <div id="end-modal" class="modal">
        <div class="bg-gray-900 p-8 border border-gray-700 text-center rounded-xl shadow-2xl max-w-md w-full">
            <h2 id="end-title" class="text-4xl title-font font-bold mb-6 text-white tracking-wider">МАТ</h2>
            <p id="end-desc" class="text-gray-400 text-sm mb-6">Игра окончена.</p>
            <div id="end-buttons" class="flex flex-col gap-3">
                <button onclick="activateNewMode()" id="btn-new-mode" class="btn btn-primary py-4 text-lg shadow-lg shadow-blue-900/50">
                    <i class="fas fa-skull mr-2"></i> ВОСКРЕСИТЬ АРМИЮ
                </button>
                <button onclick="initGame()" id="btn-restart" class="btn">Новая Игра</button>
            </div>
            <div id="winner-wait-msg" class="hidden text-emerald-400 font-mono animate-pulse">ОЖИДАНИЕ РЕШЕНИЯ СОПЕРНИКА...</div>
        </div>
    </div>

    <div id="dip-modal" class="modal">
        <div class="bg-slate-800 p-6 border-2 border-purple-500 text-center rounded-xl shadow-[0_0_50px_rgba(168,85,247,0.4)] max-w-sm">
            <h3 class="text-2xl font-bold text-purple-400 mb-2">ПРЕДЛОЖЕНИЕ СОЮЗА</h3>
            <p class="text-gray-300 text-sm mb-6">Вражеский конь предлагает слияние в Химеру.<br><span class="text-red-400 font-bold">Отказ приведет к битве.</span></p>
            <div class="flex gap-4">
                <button onclick="acceptProp()" class="btn bg-purple-600 hover:bg-purple-500 border-none">ПРИНЯТЬ</button>
                <button onclick="declineProp()" class="btn bg-red-600 hover:bg-red-500 border-none">ОТКАЗАТЬ</button>
            </div>
        </div>
    </div>

    <script>
        const GP = { k: '♔', q: '♕', r: '♖', b: '♗', n: '♘', p: '♙', a: '♖', c: '♖', h: '♞', x: '♞', z: '♕', K: '♚', Q: '♛', R: '♜', B: '♝', N: '♞', P: '♟', A: '♜', C: '♜', H: '♘', X: '♘', Z: '♛' };

        let board = [], turn = 'white', selected = null, moves = [], gameMode = 'classic';
        let chimeraTracker = {}; 
        let kingDead = false, loyalty = 3, pendingMove = null;
        let newModePlayer = null;
        let whiteRevived = false;
        let blackRevived = false;
        let moveCount = 0;
        let lastMoveData = null; 
        let aiEnabled = false;  
        let aiColor = 'black';  
        let whiteMorale = 10;
        let blackMorale = 10;

        // === ЭКОНОМИКА ===
        let economy = { white: 0, black: 0 };
        let graveyard = { white: [], black: [] }; 
        let resHist = { white: [], black: [] };   
        let shopSelected = null; 

        // Доходность
        const INCOME_VALUES = {
            'p': 1, 'P': 1,
            'k': 2, 'K': 2,
            'b': 3, 'B': 3,
            'n': 3, 'N': 3,
            'r': 5, 'R': 5,
            'h': 6, 'H': 6,
            'a': 7, 'c': 7, 'A': 7, 'C': 7, 
            'q': 8, 'Q': 8,
            'z': 8, 'Z': 8, 
            'x': 9, 'X': 9  // Химера обрабатывается отдельно
        };

        const REVIVE_COST = {
            'p': 10, 'n': 30, 'b': 30, 'r': 50
        };

        let castling = {
            white: { k: true, l: true, r: true },
            black: { k: true, l: true, r: true }
        };

        function updateLossCounters() {
            const pieceValue = { p: 1, P: 1, n: 3, N: 3, b: 3, B: 3, r: 5, R: 5, a: 8, A: 8, c: 8, C: 8, h: 6, H: 6, q: 10, Q: 10 };
            const START_VALUE = 8 * 1 + 2 * 3 + 2 * 3 + 2 * 5 + 1 * 10;
            let whiteCurrent = 0, blackCurrent = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (!p || !pieceValue[p]) continue;
                    if (p === p.toUpperCase()) blackCurrent += pieceValue[p];
                    else whiteCurrent += pieceValue[p];
                }
            }
            document.getElementById('loss-w').innerText = START_VALUE - whiteCurrent;
            document.getElementById('loss-b').innerText = START_VALUE - blackCurrent;
        }

        function updateMoraleUI() {
            document.getElementById("morale-w").innerText = whiteMorale.toFixed(1);
            document.getElementById("morale-b").innerText = blackMorale.toFixed(1);
            const colorize = (el, morale) => {
                if (morale > 6) el.style.color = "#34d399";
                else if (morale > 3) el.style.color = "#fbbf24";
                else el.style.color = "#f87171";
            };
            colorize(document.getElementById("morale-w"), whiteMorale);
            colorize(document.getElementById("morale-b"), blackMorale);
        }
        
        function updateUI() {
            document.getElementById('turn-display').innerText = turn.toUpperCase();
            document.getElementById('mode-display').innerText = gameMode === 'new_mode' ? 'LAST STAND' : 'КЛАССИКА';
            document.getElementById('loyalty').innerText = loyalty;
            
            const myColor = window.getOnlineColor();
            const showWhite = !myColor || myColor === 'white';
            const showBlack = !myColor || myColor === 'black';

            document.getElementById('coin-w').innerText = showWhite ? economy.white : '???';
            document.getElementById('coin-b').innerText = showBlack ? economy.black : '???';
            
            renderGraveyard(myColor);
        }

        function toggleAI() {
            aiEnabled = !aiEnabled;
            if (aiEnabled) {
                log("Режим ИИ включён. Вы играете против робота.");
                currentRoomId = null; myOnlineColor = null; isConnected = false;
            } else { log("Режим ИИ выключен."); }
        }

        function initGame() {
            board = [];
            const r1 = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'];
            const R1 = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'];
            for (let i = 0; i < 8; i++) {
                if (i === 0) board.push([...R1]);
                else if (i === 1) board.push(Array(8).fill('P'));
                else if (i === 6) board.push(Array(8).fill('p'));
                else if (i === 7) board.push([...r1]);
                else board.push(Array(8).fill(null));
            }
            chimeraTracker = {};
            turn = 'white'; selected = null; moves = []; gameMode = 'classic'; kingDead = false;
            loyalty = 3; pendingMove = null; newModePlayer = null;
            lastMoveData = null; moveCount = 0;

            economy = { white: 0, black: 0 };
            graveyard = { white: [], black: [] };
            resHist = { white: [], black: [] };
            shopSelected = null;

            castling = { white: { k: true, l: true, r: true }, black: { k: true, l: true, r: true } };

            document.getElementById('end-modal').classList.remove('active');
            document.getElementById('dip-modal').classList.remove('active');
            render(); updateUI();
            log("Новая партия началась.");
        }

        const getCol = (p) => { if (!p) return null; return p === p.toUpperCase() ? 'black' : 'white'; };
        const getType = (p) => p ? p.toLowerCase() : null;
        const onBd = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;
        const isLight = (r, c) => (r + c) % 2 === 0;

        function isAttacked(r, c, attackerCol) {
            const tempBoard = board.map(row => [...row]);
            const myCol = attackerCol === 'white' ? 'black' : 'white';
            const oldVal = tempBoard[r][c];
            tempBoard[r][c] = myCol === 'white' ? 'k' : 'K';
            const check = inCheck(myCol, tempBoard);
            tempBoard[r][c] = oldVal;
            return check;
        }

        function getMoves(r, c, safe = true) {
            const p = board[r][c];
            if (!p) return [];
            const col = getCol(p), type = getType(p);
            const m = [];
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            const kn = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
            const bigKn = [[4, 1], [4, -1], [-4, 1], [-4, -1], [1, 4], [1, -4], [-1, 4], [-1, -4]];

            if (type === 'p') {
                const d = col === 'white' ? -1 : 1;
                const start = col === 'white' ? 6 : 1;
                if (onBd(r + d, c) && !board[r + d][c]) {
                    m.push({ r: r + d, c });
                    if (r === start && !board[r + d * 2][c]) m.push({ r: r + d * 2, c });
                }
                [[d, 1], [d, -1]].forEach(([dr, dc]) => {
                    if (onBd(r + dr, c + dc)) {
                        const t = board[r + dr][c + dc];
                        if (t && getCol(t) !== col) m.push({ r: r + dr, c: c + dc, atk: true });
                    }
                });
            }

            if (['r', 'b', 'q', 'a', 'c'].includes(type)) {
                let myDirs = [];
                if (type === 'r' || type === 'q') myDirs.push(...dirs.slice(0, 4));
                if (type === 'b' || type === 'q') myDirs.push(...dirs.slice(4));
                if (type === 'a' || type === 'c') {
                    myDirs = [...dirs.slice(0, 4)];
                    const okDiag = (type === 'a' && isLight(r, c)) || (type === 'c' && !isLight(r, c));
                    if (okDiag) myDirs.push(...dirs.slice(4));
                }
                myDirs.forEach(([dr, dc]) => {
                    let tr = r + dr, tc = c + dc;
                    while (onBd(tr, tc)) {
                        const t = board[tr][tc];
                        if (t && getCol(t) === col) {
                            if (type === 'r' && getType(t) === 'b') m.push({ r: tr, c: tc, fuse: true });
                            if (type === 'b' && getType(t) === 'r') m.push({ r: tr, c: tc, fuse: true });
                        }
                        if (!t) { m.push({ r: tr, c: tc }); }
                        else { if (getCol(t) !== col) m.push({ r: tr, c: tc, atk: true }); break; }
                        tr += dr; tc += dc;
                    }
                });
            }

            if (['n', 'h', 'x'].includes(type)) {
                function addKnightMove(r2, c2) {
                    if (!onBd(r2, c2)) return;
                    const t = board[r2][c2];
                    if (type === 'n' && t && getType(t) === 'n' && getCol(t) !== col) {
                        m.push({ r: r2, c: c2, atk: true, prop: "chimera" });
                        return;
                    }
                    if (!t || getCol(t) !== col) { m.push({ r: r2, c: c2, atk: !!t }); }
                    if (type === 'n' && t && getCol(t) === col && getType(t) === 'n') { m.push({ r: r2, c: c2, merge: true }); }
                }
                if (type === 'n' || type === 'x') { for (const [dr, dc] of kn) addKnightMove(r + dr, c + dc); }
                if (type === 'h' || type === 'x') { for (const [dr, dc] of bigKn) addKnightMove(r + dr, c + dc); }
            }

            if (type === 'k' || type === 'z') {
                dirs.forEach(([dr, dc]) => {
                    if (onBd(r + dr, c + dc)) {
                        const t = board[r + dr][c + dc];
                        if (!t || getCol(t) !== col) m.push({ r: r + dr, c: c + dc, atk: !!t });
                    }
                });
                if (safe && type === 'k') {
                    const row = (col === 'white' ? 7 : 0);
                    if (!inCheck(col, board)) {
                        const opp = (col === 'white') ? 'black' : 'white';
                        const rookShort = board[row][7];
                        if (castling[col].k && castling[col].r && rookShort && getType(rookShort) === 'r' && getCol(rookShort) === col) {
                            if (!board[row][5] && !board[row][6] && !isAttacked(row, 5, opp) && !isAttacked(row, 6, opp)) {
                                m.push({ r: row, c: 6, castle: "short" });
                            }
                        }
                        const rookLong = board[row][0];
                        if (castling[col].k && castling[col].l && rookLong && getType(rookLong) === 'r' && getCol(rookLong) === col) {
                            if (!board[row][1] && !board[row][2] && !board[row][3] && !isAttacked(row, 3, opp) && !isAttacked(row, 2, opp)) {
                                m.push({ r: row, c: 2, castle: "long" });
                            }
                        }
                    }
                }
            }

            const finalMoves = [];
            for (let mv of m) {
                const targetP = board[mv.r][mv.c];
                if (targetP) {
                    const tType = getType(targetP);
                    const tCol = getCol(targetP);
                    if (tType === 'k') continue;
                    if (gameMode === 'new_mode' && tType === 'z' && tCol === newModePlayer) continue;
                }
                finalMoves.push(mv);
            }
            if (!safe) return finalMoves;
            const legal = [];
            for (const mv of finalMoves) {
                const tmp = board.map(row => [...row]);
                tmp[mv.r][mv.c] = tmp[r][c];
                tmp[r][c] = null;
                if (!inCheck(col, tmp)) legal.push(mv);
            }
            return legal;
        }

        function inCheck(col, bd) {
            let kr = -1, kc = -1;
            let kingSymbol = (col === 'white') ? 'k' : 'K';
            if (gameMode === 'new_mode' && kingDead && col === newModePlayer) kingSymbol = (col === 'white') ? 'z' : 'Z';
            for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { if (bd[r][c] === kingSymbol) { kr = r; kc = c; } } }
            if (kr === -1) return true;
            const opp = col === 'white' ? 'black' : 'white';
            const pawnAttackFromDir = (opp === 'white') ? 1 : -1;
            for (let dc of [-1, 1]) {
                const pr = kr + pawnAttackFromDir, pc = kc + dc;
                if (pr >= 0 && pr < 8 && pc >= 0 && pc < 8) {
                    const p = bd[pr][pc];
                    if (p && getCol(p) === opp && getType(p) === 'p') return true;
                }
            }
            const knightSmall = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
            for (let [dr, dc] of knightSmall) {
                const r = kr + dr, c = kc + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) { const p = bd[r][c]; if (p && getCol(p) === opp && getType(p) === 'n') return true; }
            }
            const knightLarge = [[4, 1], [4, -1], [-4, 1], [-4, -1], [1, 4], [1, -4], [-1, 4], [-1, -4]];
            for (let [dr, dc] of knightLarge) {
                const r = kr + dr, c = kc + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) { const p = bd[r][c]; if (p && getCol(p) === opp && getType(p) === 'h') return true; }
            }
            for (let [dr, dc] of [...knightSmall, ...knightLarge]) {
                const r = kr + dr, c = kc + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) { const p = bd[r][c]; if (p && getCol(p) === opp && getType(p) === 'x') return true; }
            }
            const rookDirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (let [dr, dc] of rookDirs) {
                let r = kr + dr, c = kc + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const p = bd[r][c];
                    if (p) {
                        const t = getType(p);
                        if (getCol(p) === opp && (t === 'r' || t === 'q' || t === 'z' || t === 'a' || t === 'c')) return true;
                        break;
                    }
                    r += dr; c += dc;
                }
            }
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (let [dr, dc] of diagDirs) {
                let r = kr + dr, c = kc + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const p = bd[r][c];
                    if (p) {
                        const t = getType(p);
                        if (getCol(p) === opp) {
                            if (t === 'b' || t === 'q' || t === 'z') return true;
                            if (t === 'a' && isLight(r, c)) return true;
                            if (t === 'c' && !isLight(r, c)) return true;
                        }
                        break;
                    }
                    r += dr; c += dc;
                }
            }
            for (let dr of [-1, 0, 1]) {
                for (let dc of [-1, 0, 1]) {
                    if (dr === 0 && dc === 0) continue;
                    const r = kr + dr, c = kc + dc;
                    if (r >= 0 && r < 8 && c >= 0 && c < 8) { const p = bd[r][c]; if (p && getCol(p) === opp && getType(p) === 'k') return true; }
                }
            }
            return false;
        }

        function checkGameState() {
            let hasMoves = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && getCol(board[r][c]) === turn) {
                        const ms = getMoves(r, c, true).filter(m => !m.fuse && !m.merge && !m.prop);
                        if (ms.length > 0) hasMoves = true;
                    }
                }
            }
            const isCheck = inCheck(turn, board);
            if (!hasMoves && isCheck) {
                log(`МАТ! Победили ${turn === 'white' ? 'Черные' : 'Белые'}`);
                document.getElementById('end-title').innerText = (turn === 'white' ? "БЕЛЫМ" : "ЧЕРНЫМ") + " МАТ";
                document.getElementById('end-desc').innerText = "Король пал. Возродить армию?";
                const btnMode = document.getElementById('btn-new-mode');
                if (turn === 'white') btnMode.style.display = whiteRevived ? 'none' : 'inline-flex';
                else btnMode.style.display = blackRevived ? 'none' : 'inline-flex';
                const buttonsBlock = document.getElementById('end-buttons');
                const waitMsg = document.getElementById('winner-wait-msg');
                if (window.isOnlineActive() && window.getOnlineColor() && window.getOnlineColor() !== turn) {
                    buttonsBlock.classList.add('hidden');
                    waitMsg.classList.remove('hidden');
                } else {
                    buttonsBlock.classList.remove('hidden');
                    waitMsg.classList.add('hidden');
                }
                document.getElementById('end-modal').classList.add('active');
            } else if (!hasMoves && !isCheck) {
                log("ПАТ! Ничья.");
                document.getElementById('end-title').innerText = "ПАТ";
                document.getElementById('end-desc').innerText = "Ничья. Ни один игрок не может сделать ход.";
                document.getElementById('btn-new-mode').style.display = 'none';
                document.getElementById('end-buttons').classList.remove('hidden');
                document.getElementById('winner-wait-msg').classList.add('hidden');
                document.getElementById('end-modal').classList.add('active');
            } else {
                document.getElementById('end-modal').classList.remove('active');
            }
        }

        function clickCell(r, c) {
            if (window.isOnlineActive() && window.getOnlineColor() && turn !== window.getOnlineColor()) return;
            
            // ЛОГИКА ПОКУПКИ (ВОСКРЕШЕНИЯ)
            if (shopSelected) {
                if (board[r][c]) {
                    log("Клетка занята!");
                    return;
                }
                
                // Зоны высадки: Белые 7-8 (index 6,7), Черные 1-2 (index 0,1)
                const isAllowedZone = (turn === 'white' && (r === 6 || r === 7)) || (turn === 'black' && (r === 0 || r === 1));
                if (!isAllowedZone) {
                    log("Нельзя! Ставьте только на стартовые линии.");
                    return;
                }

                // Лимит: 1 воскрешение за 3 хода
                const recentRevives = resHist[turn].filter(m => m > moveCount - 3).length;
                if (recentRevives >= 1) {
                    log("ЛИМИТ! Только 1 воскрешение за 3 хода.");
                    cancelShop();
                    return;
                }

                let pieceChar = shopSelected.toLowerCase(); 
                if (turn === 'black') pieceChar = pieceChar.toUpperCase();

                board[r][c] = pieceChar;
                economy[turn] -= REVIVE_COST[shopSelected.toLowerCase()];
                
                const gIndex = graveyard[turn].indexOf(shopSelected);
                if (gIndex > -1) graveyard[turn].splice(gIndex, 1);

                resHist[turn].push(moveCount);
                
                log(`ВОСКРЕШЕНИЕ: ${GP[pieceChar]}`);
                cancelShop();
                endTurn(r, c, {r, c}, {from:{r,c}, to:{r,c}}); 
                return;
            }

            if (selected) {
                const mv = moves.find(m => m.r === r && m.c === c);
                if (mv) { doMove(mv); return; }
            }
            if (board[r][c] && getCol(board[r][c]) === turn) {
                if (window.isOnlineActive() && window.getOnlineColor() && getCol(board[r][c]) !== window.getOnlineColor()) return;
                selected = { r, c }; moves = getMoves(r, c); render();
            } else { selected = null; moves = []; render(); }
        }

        function doMove(mv) {
            const start = selected;
            const p = board[start.r][start.c];
            const type = getType(p);
            const col = getCol(p);
            const moveDetails = { from: start, to: mv, proposal: !!mv.prop };

            if (mv.prop && window.isOnlineActive()) {
                window.sendMoveToCloud(board, turn, moveDetails, castling, gameMode);
                log("Предложение союза отправлено...");
                selected = null; moves = []; render();
                return;
            }
            if (mv.prop) { pendingMove = mv; document.getElementById('dip-modal').classList.add('active'); return; }

            // === ОБРАБОТКА ВЗЯТИЯ (ЭКОНОМИКА) ===
            const targetP = board[mv.r][mv.c];
            if (targetP) {
                const tType = getType(targetP);
                const tCol = getCol(targetP);
                const isMerge = (getCol(targetP) === col); 
                
                if (!isMerge && REVIVE_COST[tType]) {
                    graveyard[tCol].push(tType);
                }
            }

            const targetKey = `${mv.r},${mv.c}`;
            if (chimeraTracker[targetKey] !== undefined) delete chimeraTracker[targetKey];
            if (getType(p) === 'x') {
                const startKey = `${start.r},${start.c}`;
                if (chimeraTracker[startKey] !== undefined) {
                    chimeraTracker[targetKey] = chimeraTracker[startKey];
                    delete chimeraTracker[startKey];
                } else { chimeraTracker[targetKey] = 0; }
            }
            if (type === 'k') castling[turn].k = false;
            if (type === 'r') {
                const row = turn === 'white' ? 7 : 0;
                if (start.r === row && start.c === 0) castling[turn].l = false;
                if (start.r === row && start.c === 7) castling[turn].r = false;
            }
            if (type === 'n') {
                const target = board[mv.r][mv.c];
                if (target && getCol(target) === col && getType(target) === 'n') {
                    board[mv.r][mv.c] = (col === 'white' ? 'h' : 'H');
                    board[start.r][start.c] = null;
                    log("ЛЕГИОН: Объединение завершено.");
                    endTurn(start.r, start.c, mv, moveDetails);
                    return;
                }
                if (type === 'n' && mv.prop === "chimera") {
                    const target = board[mv.r][mv.c];
                    if (target && getType(target) === 'n' && getCol(target) !== col) {
                        pendingMove = mv;
                        pendingMove.from = start;
                        pendingMove.to = { r: mv.r, c: mv.c };
                        pendingMove.attackerColor = col;
                        document.getElementById('dip-modal').classList.add('active');
                        log("Предложение: создать ХИМЕРУ");
                        return;
                    }
                }
            }
            if (mv.fuse) {
                const isL = isLight(start.r, start.c);
                const code = turn === 'white' ? (isL ? 'a' : 'c') : (isL ? 'A' : 'C');
                board[mv.r][mv.c] = code;
                board[start.r][start.c] = null;
                log('СЛИЯНИЕ: Канцлер создан.');
            } else if (mv.castle) {
                board[mv.r][mv.c] = p;
                board[start.r][start.c] = null;
                castling[turn].k = false;
                const row = turn === 'white' ? 7 : 0;
                if (mv.castle === 'short') { board[row][5] = board[row][7]; board[row][7] = null; } 
                else { board[row][3] = board[row][0]; board[row][0] = null; }
                log('РОКИРОВКА!');
            } else {
                board[mv.r][mv.c] = p;
                board[start.r][start.c] = null;
                if (type === 'p' && (mv.r === 0 || mv.r === 7)) {
                    if (gameMode === 'new_mode') { board[mv.r][mv.c] = turn === 'white' ? 'q' : 'Q'; log("ПРОМОУШН: Создан Ферзь."); } 
                    else { board[mv.r][mv.c] = turn === 'white' ? 'q' : 'Q'; }
                }
            }
            endTurn(start.r, start.c, mv, moveDetails);
        }

        function calculateIncome(playerColor) {
            let income = 0;
            let chimeraCount = 0;

            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    const p = board[r][c];
                    if(!p) continue;
                    
                    const type = getType(p);
                    const val = INCOME_VALUES[p] || 0;

                    if (type === 'x') {
                        chimeraCount++;
                        continue;
                    }

                    if (getCol(p) === playerColor) {
                        income += val;
                    }
                }
            }
            if (chimeraCount > 0) income += (chimeraCount * 9);

            return income;
        }

        function endTurn(sr, sc, mv, moveDetails) {
            const nextTurn = turn === 'white' ? 'black' : 'white';
            moveCount++;

            // === ХИМЕРА ЛОГИКА ===
            const justFinishedPlayer = turn; 
            for (const key in chimeraTracker) {
                const [r, c] = key.split(',').map(Number);
                const p = board[r][c];
                if (p && getType(p) === 'x') {
                    const owner = getCol(p);
                    if (owner === justFinishedPlayer) {
                        chimeraTracker[key]++; 
                        if (chimeraTracker[key] >= 2) {
                            const newType = (p === 'x') ? 'X' : 'x'; 
                            board[r][c] = newType;
                            chimeraTracker[key] = 0; 
                            log(`ХИМЕРА на ${String.fromCharCode(97 + c)}${8 - r} сменила лояльность!`);
                        }
                    }
                } else { delete chimeraTracker[key]; }
            }

            // === ДОХОД РАЗ В 5 ХОДОВ (РАУНДОВ) ===
            // 5 полных ходов = 10 полуходов
            if (moveCount > 0 && moveCount % 10 === 0) {
                economy.white += calculateIncome('white');
                economy.black += calculateIncome('black');
                log("💰 ДЕНЬ ЖАЛОВАНИЯ: Оба игрока получили доход!");
            }

            if (!moveDetails && typeof sr !== 'undefined') { moveDetails = { from: { r: sr, c: sc }, to: mv }; }

            if (window.isOnlineActive()) {
                window.sendMoveToCloud(board, nextTurn, moveDetails, castling, gameMode, moveCount);
            }

            loyalty--;
            if (loyalty <= 0) { consultGeminiLoyalty(); loyalty = 3; }

            turn = nextTurn;
            selected = null; moves = [];
            lastMoveData = moveDetails;
            updateLossCounters();
            updateUI(); render(); updateMoraleUI();

            if (aiEnabled && turn === aiColor) {
                setTimeout(() => {
                    const before = lastMoveData;
                    makeAIMove();
                    setTimeout(() => { if (before === lastMoveData) { checkGameState(); } }, 50);
                }, 150);
                return;
            }
            checkGameState();
        }

        // === ИНТЕРФЕЙС ЭКОНОМИКИ (RENDER) ===
        function renderGraveyard(myColor) {
            const container = document.getElementById('graveyard-list');
            container.innerHTML = '';
            
            const isMyTurn = (!myColor) || (myColor === turn);
            
            if (!isMyTurn) {
                container.innerHTML = '<div class="text-gray-500 text-xs italic text-center mt-2">Магазин противника скрыт</div>';
                return;
            }

            const list = graveyard[turn];
            if (!list || list.length === 0) {
                container.innerHTML = '<div class="text-gray-500 text-xs italic">Пусто...</div>';
                return;
            }
            
            const counts = {};
            list.forEach(x => { counts[x] = (counts[x] || 0) + 1; });

            for (const [type, count] of Object.entries(counts)) {
                const div = document.createElement('div');
                div.className = 'shop-item';
                if (shopSelected === type) div.classList.add('active');

                const cost = REVIVE_COST[type];
                const canAfford = economy[turn] >= cost;
                
                div.onclick = () => {
                    if (window.isOnlineActive() && window.getOnlineColor() !== turn) return;
                    if (!canAfford) { alert('Недостаточно монет!'); return; }
                    selectShopItem(type);
                };

                const pieceSymbol = GP[turn === 'white' ? type : type.toUpperCase()]; 

                div.innerHTML = `
                    <div class="flex items-center">
                        <span class="shop-piece mr-2 text-white">${pieceSymbol}</span>
                        <span class="text-xs text-gray-300">x${count}</span>
                    </div>
                    <div class="flex items-center">
                        <i class="fas fa-coins coin-icon text-[10px]"></i>
                        <span class="text-xs font-bold ${canAfford ? 'text-yellow-400' : 'text-red-500'}">${cost}</span>
                    </div>
                `;
                container.appendChild(div);
            }
        }

        function selectShopItem(type) {
            shopSelected = type;
            document.getElementById('cancel-shop-btn').classList.remove('hidden');
            renderGraveyard(window.getOnlineColor()); 
            render(); 
            log(`Выбрано: ${type.toUpperCase()}. Доступны только стартовые линии.`);
        }

        window.cancelShop = () => {
            shopSelected = null;
            document.getElementById('cancel-shop-btn').classList.add('hidden');
            renderGraveyard(window.getOnlineColor());
            render();
        }

        function log(t) { const l = document.getElementById('log'); l.innerHTML = `<div>> ${t}</div>` + l.innerHTML; }

        function consultGeminiLoyalty() {
            const whiteLoss = parseInt(document.getElementById("loss-w").innerText);
            const blackLoss = parseInt(document.getElementById("loss-b").innerText);
            whiteMorale = Math.max(0, 10 - whiteLoss / 3);
            blackMorale = Math.max(0, 10 - blackLoss / 3);
            for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const p = board[r][c]; if (!p || getType(p) !== 'p') continue; const color = getCol(p); const morale = (color === "white") ? whiteMorale : blackMorale; if (morale > 3) continue; let chance = 0; if (morale <= 3) chance = 0.05 + Math.random() * 0.10; if (morale <= 1) chance = 0.20 + Math.random() * 0.10; let enemyNearby = false; const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]]; for (let [dr, dc] of dirs) { const rr = r + dr, cc = c + dc; if (!onBd(rr, cc)) continue; const enemy = board[rr][cc]; if (enemy && getCol(enemy) !== color) { enemyNearby = true; break; } } if (!enemyNearby) continue; if (Math.random() < chance) { board[r][c] = (color === "white") ? "P" : "p"; log(`⚠ Пешка на (${r},${c}) изменила сторону!`); } } }
            updateMoraleUI(); render();
        }
        function isSquareThreatened(bd, r, c, byColor) {
            if (byColor === "white") { let rr = r + 1; for (let dc of [-1, +1]) { let cc = c + dc; if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (p && getCol(p) === "white" && getType(p) === "p") return true; } } } else { let rr = r - 1; for (let dc of [-1, +1]) { let cc = c + dc; if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (p && getCol(p) === "black" && getType(p) === "p") return true; } } }
            const knightSmall = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]]; const knightLarge = [[4, 1], [4, -1], [-4, 1], [-4, -1], [1, 4], [1, -4], [-1, 4], [-1, -4]]; for (let [dr, dc] of [...knightSmall, ...knightLarge]) { let rr = r + dr, cc = c + dc; if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (!p) continue; if (getCol(p) !== byColor) continue; let t = getType(p); if (t === 'n' && knightSmall.some(k => k[0] === dr && k[1] === dc)) return true; if (t === 'h' && knightLarge.some(k => k[0] === dr && k[1] === dc)) return true; if (t === 'x') return true; } }
            const rookDirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]; for (let [dr, dc] of rookDirs) { let rr = r + dr, cc = c + dc; while (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (p) { if (getCol(p) === byColor) { let t = getType(p); if (t === 'r' || t === 'q' || t === 'z' || t === 'a' || t === 'c') return true; } break; } rr += dr; cc += dc; } }
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]]; for (let [dr, dc] of diagDirs) { let rr = r + dr, cc = c + dc; while (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (p) { if (getCol(p) === byColor) { let t = getType(p); if (t === 'b' || t === 'q' || t === 'z' || t === 'a' || t === 'c') return true; } break; } rr += dr; cc += dc; } }
            for (let dr of [-1, 0, 1]) { for (let dc of [-1, 0, 1]) { if (dr === 0 && dc === 0) continue; let rr = r + dr, cc = c + dc; if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (p && getCol(p) === byColor && getType(p) === 'k') return true; } } }
            return false;
        }
        function checkLoyaltyLocal(wLoss, bLoss) { const lossDiff = wLoss - bLoss; for (let r = 0; r < 8; r++)for (let c = 0; c < 8; c++) { const p = board[r][c]; if (p && getType(p) === 'p') { let isolated = true; for (let dc of [-1, 1]) { if (onBd(r, c + dc) && board[r][c + dc] && getCol(board[r][c + dc]) === getCol(p)) isolated = false; } let chance = 0.1; if (isolated) chance += 0.2; if (getCol(p) === 'white' && lossDiff >= 2 && Math.random() < chance) { board[r][c] = 'P'; log('ИЗМЕНА! Белая пешка перешла к черным.'); } if (getCol(p) === 'black' && lossDiff <= -2 && Math.random() < chance) { board[r][c] = 'p'; log('ИЗМЕНА! Черная пешка перешла к белым.'); } } } }
        window.activateNewMode = () => { const player = turn; if (player === 'white') whiteRevived = true; else blackRevived = true; gameMode = 'new_mode'; newModePlayer = player; kingDead = true; document.getElementById('end-modal').classList.remove('active'); let legions = 0, archons = 0; for (let r = 0; r < 8; r++)for (let c = 0; c < 8; c++) { const p = board[r][c]; if (p && getCol(p) === player) { if (['h', 'x'].includes(getType(p))) legions++; if (['a', 'c'].includes(getType(p))) archons++; } } for (let r = 0; r < 8; r++)for (let c = 0; c < 8; c++) if (board[r][c] && getCol(board[r][c]) === player) board[r][c] = null; const baseR = player === 'white' ? 7 : 0, pawnR = player === 'white' ? 6 : 1; const r1 = player === 'white' ? ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'] : ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']; board[baseR] = [...r1]; board[pawnR] = Array(8).fill(player === 'white' ? 'p' : 'P'); for (let c = 0; c < 8; c++) { const p = board[baseR][c]; if (getType(p) === 'n' && legions > 0) { board[baseR][c] = player === 'white' ? 'h' : 'H'; legions--; } if (getType(p) === 'r' && archons > 0) { const isL = isLight(baseR, c); board[baseR][c] = player === 'white' ? (isL ? 'a' : 'c') : (isL ? 'A' : 'C'); archons--; } } board[baseR][4] = null; board[baseR][3] = player === 'white' ? 'z' : 'Z'; log("НОВЫЙ РЕЖИМ! Король мертв. Ферзь (Z) — Лидер."); if (window.isOnlineActive()) window.sendMoveToCloud(board, turn, {}, castling, gameMode); render(); };
        window.acceptProp = () => { document.getElementById('dip-modal').classList.remove('active'); const code = turn === 'white' ? 'X' : 'x'; board[pendingMove.r][pendingMove.c] = code; board[selected.r][selected.c] = null; const key = `${pendingMove.r},${pendingMove.c}`; chimeraTracker[key] = 0; log('ХИМЕРА рождена. Лояльность нестабильна.'); endTurn(selected.r, selected.c, pendingMove); pendingMove = null; };
        window.declineProp = () => { document.getElementById('dip-modal').classList.remove('active'); board[pendingMove.r][pendingMove.c] = board[selected.r][selected.c]; board[selected.r][selected.c] = null; log('ОТКАЗ. Враг уничтожен.'); endTurn(selected.r, selected.c, pendingMove); pendingMove = null; };
        function render() { const div = document.getElementById('board'); const svg = document.getElementById('svg-overlay'); const cells = div.querySelectorAll('.cell'); cells.forEach(c => c.remove()); svg.innerHTML = ''; let inChk = inCheck(turn, board); const wrapper = document.querySelector('.board-wrapper'); const isFlipped = (myOnlineColor === 'black'); if (isFlipped) wrapper.classList.add('flipped'); else wrapper.classList.remove('flipped'); for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const d = document.createElement('div'); d.className = `cell ${(r + c) % 2 ? 'dark' : 'light'}`; if (selected && selected.r === r && selected.c === c) d.classList.add('selected'); if (shopSelected && !board[r][c]) { d.classList.add('place-mode'); const isAllowed = (turn === 'white' && (r === 6 || r === 7)) || (turn === 'black' && (r === 0 || r === 1)); if(isAllowed) d.classList.add('allowed-zone'); } const p = board[r][c]; if (inChk && p && getCol(p) === turn) { const target = (gameMode === 'new_mode' && kingDead && turn === newModePlayer) ? 'z' : 'k'; if (getType(p) === target) d.classList.add('check'); } if (p) { const s = document.createElement('span'); s.className = `piece ${getCol(p)}`; const t = getType(p); if (t === 'a' || t === 'c') { s.classList.add('archon'); if (t === 'a') s.classList.add('archon-light'); else s.classList.add('archon-dark'); s.innerHTML += `<span class="badge">${t === 'a' ? 'A' : 'C'}</span>`; } if (t === 'h') { s.classList.add('legion'); s.innerHTML += `<span class="badge">L</span>`; } if (t === 'x') { s.classList.add('chimera'); s.innerHTML += `<span class="badge">X</span>`; } if (t === 'z') { s.classList.add('heavy'); s.innerHTML += `<span class="badge">Z</span>`; } s.innerText = GP[p] || GP[getType(p) === 'z' ? (getCol(p) === 'white' ? 'q' : 'Q') : p] || p; d.appendChild(s); } const mv = moves.find(m => m.r === r && m.c === c); if (mv && !shopSelected) { const h = document.createElement('div'); h.className = 'hint'; if (mv.prop) h.classList.add('union-hint'); else if (mv.atk) h.classList.add('attack-hint'); else if (mv.fuse) { h.classList.add('special-hint', 'fuse'); h.innerText = 'FUSE'; } else if (mv.merge) { h.classList.add('special-hint', 'legion'); h.innerText = 'LEGION'; } else if (mv.castle) { h.classList.add('special-hint', 'castle'); h.innerText = 'CASTLE'; } else h.classList.add('move-hint'); d.appendChild(h); } d.onclick = () => clickCell(r, c); div.appendChild(d); } }; if (lastMoveData && lastMoveData.from && lastMoveData.to) { const line = document.createElementNS("http://www.w3.org/2000/svg", "line"); line.classList.add("last-move-purple"); const x1 = (lastMoveData.from.c * 12.5 + 6.25) + '%'; const y1 = (lastMoveData.from.r * 12.5 + 6.25) + '%'; const x2 = (lastMoveData.to.c * 12.5 + 6.25) + '%'; const y2 = (lastMoveData.to.r * 12.5 + 6.25) + '%'; line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2); line.setAttribute('stroke', 'rgba(124, 58, 237, 0.5)'); line.setAttribute('stroke-width', '6'); line.setAttribute('stroke-linecap', 'round'); svg.appendChild(line); } }
        function isDefended(bd, r, c, color) { if (color === "white") { let rr = r + 1; for (let dc of [-1, +1]) { let cc = c + dc; if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { const p = bd[rr][cc]; if (p && getCol(p) === "white" && getType(p) === "p") return true; } } } else { let rr = r - 1; for (let dc of [-1, +1]) { let cc = c + dc; if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { const p = bd[rr][cc]; if (p && getCol(p) === "black" && getType(p) === "p") return true; } } } const knightSmall = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]]; const knightLarge = [[4, 1], [4, -1], [-4, 1], [-4, -1], [1, 4], [1, -4], [-1, 4], [-1, -4]]; for (let [dr, dc] of [...knightSmall, ...knightLarge]) { let rr = r + dr, cc = c + dc; if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (!p || getCol(p) !== color) continue; let t = getType(p); if (t === "n" && knightSmall.some(k => k[0] === dr && k[1] === dc)) return true; if (t === "h" && knightLarge.some(k => k[0] === dr && k[1] === dc)) return true; if (t === "x") return true; } } const rookDirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]; for (let [dr, dc] of rookDirs) { let rr = r + dr, cc = c + dc; while (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (p) { if (getCol(p) === color) { let t = getType(p); if (t === "r" || t === "q" || t === "z" || t === "a" || t === "c") return true; } break; } rr += dr; cc += dc; } } const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]]; for (let [dr, dc] of diagDirs) { let rr = r + dr, cc = c + dc; while (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (p) { if (getCol(p) === color) { let t = getType(p); if (t === "b" || t === "q" || t === "z" || t === "a" || t === "c") return true; } break; } rr += dr; cc += dc; } } for (let dr of [-1, 0, 1]) { for (let dc of [-1, 0, 1]) { if (dr === 0 && dc === 0) continue; let rr = r + dr, cc = c + dc; if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) { let p = bd[rr][cc]; if (p && getCol(p) === color && getType(p) === "k") return true; } } } return false; }
        function getGlobalThreatScore(bd, color) { let score = 0; const opp = opposite(color); for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const p = bd[r][c]; if (!p || getCol(p) !== color) continue; if (isSquareThreatened(bd, r, c, opp)) { if (getType(p) !== 'k') { score += getPieceValue(p); } } } } return score; }
        function makeAIMove() { if (!aiEnabled) return; if (window.isOnlineActive()) return; if (pendingMove) { declineProp(); return; } let bestScore = -999999; let bestMove = null; const currentlyInCheck = inCheck(aiColor, board); const currentDanger = getGlobalThreatScore(board, aiColor); for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { if (!board[r][c] || getCol(board[r][c]) !== aiColor) continue; let rawMoves = getMoves(r, c, false).filter(m => !m.prop && !m.merge && !m.fuse); let legalMoves = []; for (let mv of rawMoves) { const after = simulateMove(board, { r, c }, mv); if (!inCheck(aiColor, after)) legalMoves.push(mv); } if (legalMoves.length === 0) continue; for (let mv of legalMoves) { const score = evaluateMove({ r, c }, mv, board, aiColor, currentlyInCheck, currentDanger); const randomNoise = Math.random() * 0.5; if (score + randomNoise > bestScore) { bestScore = score + randomNoise; bestMove = { from: { r, c }, to: mv }; } } } } if (!bestMove) return; executeAImove(bestMove); }
        function evaluateMove(from, mv, board, color, isCheckMode, initialDanger) { let score = 0; const piece = board[from.r][from.c]; const target = board[mv.r][mv.c]; const pieceType = getType(piece); const after = simulateMove(board, from, mv); const futureDanger = getGlobalThreatScore(after, color); const dangerDiff = initialDanger - futureDanger; score += dangerDiff * 2; if (target) { let val = getPieceValue(target); score += val * 1.5; if (!isSquareThreatened(after, mv.r, mv.c, opposite(color))) { score += 2; } } const attackedNew = isSquareThreatened(after, mv.r, mv.c, opposite(color)); const defendedNew = isDefended(after, mv.r, mv.c, color); if (attackedNew) { let lossValue = getPieceValue(piece); if (defendedNew) { score -= lossValue * 0.5; } else { score -= lossValue * 2; } } if (inCheck(opposite(color), after)) score += 3; if ([3, 4].includes(mv.r) && [3, 4].includes(mv.c)) score += 0.5; if (pieceType === 'p' && (color === 'white' ? from.r === 1 : from.r === 6)) score += 1; if (pieceType === 'k' && !isCheckMode) score -= 1; return score; }
        function getPieceValue(p) { if (!p) return 0; p = p.toLowerCase(); return { 'p': 1, 'n': 3, 'h': 5, 'b': 3, 'r': 5, 'a': 7, 'c': 7, 'q': 9, 'x': 7, 'z': 10, 'k': 100 }[p] || 0; }
        function opposite(col) { return col === 'white' ? 'black' : 'white'; }
        function simulateMove(bd, from, to) { let copy = bd.map(row => [...row]); copy[to.r][to.c] = copy[from.r][from.c]; copy[from.r][from.c] = null; return copy; }
        function executeAImove(move) { selected = move.from; doMove(move.to); selected = null; }

        initGame();
    </script>
</body>
</html>
