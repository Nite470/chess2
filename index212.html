<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess 2: LAN Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <script>
        // === НАСТРОЙКИ GEMINI AI ===
        // Вставлен твой ключ. 
        // Используем модель gemini-1.5-flash для скорости.
        const GEMINI_API_KEY = 'AIzaSyDuQ89DuJCXx9kJoS7qFDWaiNqSYf6l1jI'; 

        let socket;
        let currentRoomId = null;
        let myOnlineColor = null;
        let isConnected = false;

     // ВАЖНО: Замените старую функцию connectToServer на эту
        function connectToServer() {
            // Теперь нам не нужно поле ввода IP. 
            // Мы подключаемся к тому же адресу, где открыт сайт.
            const serverUrl = window.location.origin; 
            
            const btn = document.getElementById('btn-connect');
            if(btn) {
                btn.innerText = "Подключение...";
                btn.disabled = true;
            }

            // Убираем явное указание URL, socket.io сам определит хост
            socket = io(); 

            socket.on('connect', () => {
                isConnected = true;
                document.getElementById('online-status').innerText = "СЕРВЕР: ПОДКЛЮЧЕН";
                document.getElementById('online-status').classList.replace('text-gray-500', 'text-emerald-400');
                if(btn) btn.innerText = "OK";
                
                // Скрываем панель ввода IP, она больше не нужна
                const connPanel = document.getElementById('connection-panel');
                if(connPanel) connPanel.classList.add('hidden');
                
                document.getElementById('lobby-panel').classList.remove('hidden');
            });

            socket.on('connect_error', (err) => {
                // Если хостинг "спит" (бесплатный тариф), первое подключение может быть долгим
                console.log("Попытка подключения...", err);
            });

            setupSocketListeners();
        }

        // Добавьте это в самый низ скрипта или замените <body onload="...">
        // Чтобы подключение происходило сразу при открытии страницы
        window.onload = () => {
            connectToServer();
        };
        function setupSocketListeners() {
            socket.on('room_list', (rooms) => {
                const listEl = document.getElementById('room-list-container');
                listEl.innerHTML = ''; 
                if (rooms.length === 0) {
                    listEl.innerHTML = '<div class="text-gray-500 text-[10px] italic">Нет доступных комнат</div>';
                    return;
                }
                rooms.forEach(room => {
                    const roomBtn = document.createElement('button');
                    roomBtn.className = "w-full text-left bg-slate-800 hover:bg-slate-700 border border-slate-600 p-2 mb-1 rounded text-xs flex justify-between items-center group transition-all";
                    roomBtn.onclick = () => {
                        document.getElementById('room-input').value = room.id;
                        joinGame();
                    };
                    roomBtn.innerHTML = `
                        <span class="text-blue-400 font-mono font-bold group-hover:text-blue-300">#${room.id}</span>
                        <span class="text-gray-400 text-[9px]">Игроков: ${room.count}/2</span>
                    `;
                    listEl.appendChild(roomBtn);
                });
            });

            socket.on('player_joined', (data) => {
                log(`Игрок подключился! Комната: ${data.roomId}`);
                document.getElementById('online-msg').innerText = "Соперник в игре!";
            });

            socket.on('game_start', (data) => {
                myOnlineColor = data.color;
                currentRoomId = data.roomId;
                window.syncBoardFromOnline(data.board, data.turn, data.castling);
                window.enterOnlineMode(data.roomId, `Вы играете за: ${myOnlineColor === 'white' ? 'БЕЛЫХ' : 'ЧЕРНЫХ'}`);
                log(`Игра началась! Ваш цвет: ${myOnlineColor.toUpperCase()}`);
            });

            socket.on('receive_move', (data) => {
                if (data.mode && gameMode !== data.mode) {
                    gameMode = data.mode;
                    if (data.mode === 'new_mode') {
                        kingDead = true;
                        newModePlayer = data.turn; 
                    }
                }

                document.getElementById('dip-modal').classList.remove('active');

                if (data.lastMove && data.lastMove.proposal) {
                    if (myOnlineColor && myOnlineColor === data.turn) {
                        log("Ожидание ответа соперника на союз...");
                    } else {
                        pendingMove = data.lastMove.to;
                        selected = data.lastMove.from;
                        document.getElementById('dip-modal').classList.add('active');
                        log("Получено предложение союза!");
                    }
                } else {
                    window.syncBoardFromOnline(data.board, data.turn, data.castling);
                    
                    // Сохраняем последний ход для отрисовки линии
                    lastMoveData = data.lastMove || null;

                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            if (board[r][c] === 'x') board[r][c] = 'X';
                            else if (board[r][c] === 'X') board[r][c] = 'x';
                        }
                    }
                    render();
                    updateUI();
                    checkGameState(); 
                }
            });

            socket.on('error_msg', (msg) => alert(msg));
            socket.on('opponent_left', () => { alert("Соперник отключился."); location.reload(); });
        }

        window.hostGame = () => {
            if (!isConnected) return alert("Сначала подключитесь к серверу!");
            const roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
            socket.emit('create_room', roomId);
            window.enterOnlineMode(roomId, "Ожидание соперника...");
        };

        window.joinGame = () => {
            if (!isConnected) return alert("Сначала подключитесь к серверу!");
            const roomId = document.getElementById('room-input').value.toUpperCase();
            if (!roomId) return alert("Введите ID комнаты");
            socket.emit('join_room', roomId);
        };

        window.enterOnlineMode = (id, status) => {
            document.getElementById('lobby-panel').classList.add('hidden');
            document.getElementById('online-active-ui').classList.remove('hidden');
            document.getElementById('room-display').innerText = id;
            document.getElementById('online-msg').innerText = status;
        };

        window.sendMoveToCloud = (boardState, nextTurn, moveDetails, castlingState, modeState) => {
            if (!socket || !currentRoomId) return;
            socket.emit('make_move', {
                roomId: currentRoomId,
                board: boardState,
                turn: nextTurn,
                lastMove: moveDetails,
                castling: castlingState,
                mode: modeState || gameMode 
            });
        };

        window.getOnlineColor = () => myOnlineColor;
        window.isOnlineActive = () => !!currentRoomId;
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap');
        :root { --bg: #0f172a; --dark: #1e293b; --light: #475569; --gold: #fbbf24; --blue: #3b82f6; --purp: #d946ef; --red: #ef4444; }
        body { background: var(--bg); color: #e2e8f0; font-family: 'Roboto Mono', monospace; overflow: hidden; user-select: none; }
        .title-font { font-family: 'Orbitron', sans-serif; }
        
        .board-wrapper { 
            width: 100%; max-width: 80vh; aspect-ratio: 1; 
            display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); 
            border: 8px solid #334155; box-shadow: 0 0 50px rgba(0,0,0,0.5); 
            position: relative; /* Для SVG оверлея */
            transition: transform 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* Анимация переворота */
        }
        /* Анимация мерцания линии */
        @keyframes glowPurple {
            0% {
                stroke-opacity: 1;
                filter: drop-shadow(0 0 4px rgba(168, 85, 247, 0.8));
            }

            50% {
                stroke-opacity: 0.4;
                filter: drop-shadow(0 0 12px rgba(168, 85, 247, 1));
            }

            100% {
                stroke-opacity: 1;
                filter: drop-shadow(0 0 4px rgba(168, 85, 247, 0.8));
            }
        }

        .last-move-purple {
            animation: glowPurple 1.2s infinite ease-in-out;
        }


        /* Стиль для линии последнего хода */
        .last-move-line {
            filter: drop-shadow(0 0 12px rgba(255, 220, 0, 0.9));
            animation: glowLine 1s infinite;
        }

        /* Класс для перевернутой доски */
        .board-wrapper.flipped { transform: rotate(180deg); }
        .board-wrapper.flipped .cell { transform: rotate(180deg); } /* Поворачиваем фигуры обратно */

        .cell { display: flex; justify-content: center; align-items: center; font-size: clamp(1rem, 5vmin, 4rem); cursor: pointer; position: relative; overflow: hidden; transition: transform 0.8s; }
        .cell.light { background: var(--light); color: #cbd5e0; } .cell.dark { background: var(--dark); color: #94a3b8; }
        .cell.selected { background: rgba(251, 191, 36, 0.3) !important; box-shadow: inset 0 0 10px var(--gold); } 
        .cell.check { background: rgba(239, 68, 68, 0.6) !important; }
        .hint { position: absolute; pointer-events: none; z-index: 20; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        .move-hint::after { content:''; width: 20%; height: 20%; background: rgba(16, 185, 129, 0.6); border-radius: 50%; }
        .attack-hint { border: 4px solid rgba(239, 68, 68, 0.6); }
        .union-hint { border: 4px solid var(--purp); box-shadow: inset 0 0 15px var(--purp); }
        
        /* SVG Оверлей для линий хода */
        #svg-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 15;
        }
        
        .special-hint { font-size: 0.6em; font-weight: bold; border: 2px solid; background: rgba(0,0,0,0.5); padding: 2px 4px; border-radius: 4px; }
        .special-hint.fuse { border-color: var(--gold); color: var(--gold); }
        .special-hint.legion { border-color: var(--blue); color: var(--blue); }
        .special-hint.union { border-color: var(--purp); color: var(--purp); }
        .special-hint.castle { border-color: rgb(255, 146, 3); color: white; }
        .piece { z-index: 10; filter: drop-shadow(0 4px 2px rgba(0,0,0,0.5)); max-width: 90%; max-height: 90%; line-height: 1; transition: transform 0.2s; }
        .piece:hover { transform: scale(1.1); }
        .piece.white { color: #f8fafc; text-shadow: 0 0 5px rgba(255,255,255,0.2); }
        .piece.black { color: #020617; text-shadow: 0 0 2px rgba(255,255,255,0.2); stroke: 1px white; }
        .piece.archon { color: var(--gold) !important; filter: drop-shadow(0 0 10px var(--gold)); }
        .piece.legion { color: var(--blue) !important; filter: drop-shadow(0 0 10px var(--blue)); }
        .piece.chimera { color: var(--purp) !important; filter: drop-shadow(0 0 10px var(--purp)); animation: pulse 2s infinite; }
        .piece.heavy { color: #f43f5e !important; filter: drop-shadow(0 0 10px #f43f5e); }
        @keyframes pulse { 0%,100%{filter:drop-shadow(0 0 5px var(--purp));} 50%{filter:drop-shadow(0 0 15px var(--purp));} }
        .badge { position: absolute; bottom: 1px; right: 1px; font-size: 0.4em; pointer-events: none; font-family: sans-serif; font-weight: bold; }
        .btn { background: #1e293b; border: 1px solid #475569; padding: 10px; color: white; width: 100%; margin-bottom: 5px; cursor: pointer; transition: 0.2s; font-weight: bold; text-transform: uppercase; font-size: 0.8rem; }
        .btn:hover { background: #334155; border-color: white; }
        .btn-primary { background: #1d4ed8; border-color: #3b82f6; }
        .btn-danger { background: #b91c1c; border-color: #ef4444; }
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 50; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal.active { display: flex; }
        .stat-box { background: #1e293b; padding: 10px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #334155; }
        input.dark-input { background: #0f172a; border: 1px solid #334155; color: white; padding: 8px; width: 100%; font-family: monospace; }
        .piece.archon-light { color: #ffd700 !important; filter: drop-shadow(0 0 10px #ffeb3b); }
        .piece.archon-dark { color: #00e5ff !important; filter: drop-shadow(0 0 10px #00e5ff); }
        /* === МОБИЛЬНАЯ АДАПТАЦИЯ === */
        @media (max-width: 700px) {

            /* Убираем лишнее, фокус на доске */
            body {
                overflow: auto;
            }

            /* Левая панель становится компактной */
            .w-full.md\:w-80 {
                width: 100% !important;
                max-height: 35vh;
                overflow-y: auto;
            }

            /* Основная часть (доска) занимает весь экран */
            .flex-1 {
                height: 65vh !important;
                padding: 0 !important;
            }

            /* Доска подстраивается под ширину экрана */
            .board-wrapper {
                max-width: 95vw !important;
                width: 95vw !important;
                height: 95vw !important; /* квадрат */
                aspect-ratio: 1 !important;
            }

            /* Клетки делают фигуры крупнее */
            .cell {
                font-size: 6vw !important;
            }

            .piece {
                max-width: 85% !important;
                max-height: 85% !important;
            }

            /* Лог уменьшается */
            #log {
                max-height: 150px;
            }
        }

    </style>
</head>
<body class="flex flex-col md:flex-row h-screen">

    <!-- Sidebar -->
    <div class="w-full md:w-80 bg-[#020617] p-6 border-r border-[#1e293b] flex flex-col z-20 shadow-2xl overflow-y-auto">
        <h1 class="text-3xl font-bold title-font mb-1 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">ШАХМАТЫ 2.0</h1>
        <div class="text-xs text-gray-500 mb-6 font-mono">LAN / RADMIN Edition</div>

        <div class="stat-box">
            <div class="flex justify-between items-center mb-2">
                <span class="text-xs text-gray-400">ХОД</span>
                <span id="turn-display" class="font-bold text-white bg-slate-700 px-2 py-1 rounded">БЕЛЫЕ</span>
            </div>
            <div class="text-[10px] text-gray-500 flex justify-between">
                <span>Режим: <span id="mode-display" class="text-blue-400">КЛАССИКА</span></span>
                <span>Лояльность: <span id="loyalty" class="text-white">3</span></span>
            </div>
        </div>
        <div class="text-[10px] text-gray-400 flex justify-between mt-1">
            <span>Мораль Белых: <span id="morale-w" class="text-emerald-400">10</span></span>
            <span>Мораль Черных: <span id="morale-b" class="text-emerald-400">10</span></span>
        </div>


        <div class="stat-box">
            <div id="online-status" class="text-[10px] text-gray-500 mb-2 font-bold">СЕТЬ: НЕ ПОДКЛЮЧЕНА</div>
            <div id="connection-panel" class="mb-4 pb-4 border-b border-gray-700">
                <label class="text-[10px] text-gray-400 block mb-1">IP сервера Radmin VPN (host:3000)</label>
                <input id="server-ip" type="text" placeholder="Пример: 26.123.45.67:3000" class="dark-input mb-2 text-xs">
                <button id="btn-connect" onclick="connectToServer()" class="btn btn-primary text-xs">Подключиться</button>
                <p class="text-[9px] text-gray-500 mt-1">* Если вы сервер, оставьте пустым (localhost)</p>
            </div>
            <div id="lobby-panel" class="hidden">
                <button onclick="hostGame()" class="btn btn-primary mb-2">Создать Комнату</button>
                <div class="flex gap-2 mb-3">
                    <input id="room-input" type="text" placeholder="ID" class="w-2/3 bg-slate-900 border border-slate-600 px-3 text-white uppercase outline-none text-sm rounded">
                    <button onclick="joinGame()" class="w-1/3 btn text-xs py-2 m-0">Войти</button>
                </div>
                <!-- Список комнат -->
                <div class="border-t border-gray-700 pt-2">
                    <div class="text-[10px] text-gray-400 mb-1">Доступные комнаты:</div>
                    <div id="room-list-container" class="max-h-[100px] overflow-y-auto">
                        <div class="text-gray-500 text-[10px] italic">Ожидание данных...</div>
                    </div>
                </div>
            </div>
            <div id="online-active-ui" class="hidden text-center">
                <div id="room-display" class="text-2xl font-mono text-green-400 border border-green-900 p-2 bg-black select-all mb-1 rounded tracking-widest">---</div>
                <div id="online-msg" class="text-[10px] text-gray-400">Ожидание...</div>
            </div>
        </div>

        <div class="stat-box text-xs">
            <div class="flex justify-between mb-1">
                <span class="text-gray-400">Потери Белых</span>
                <span id="loss-w" class="text-red-400 font-bold text-lg">0</span>
            </div>
            <div class="flex justify-between">
                <span class="text-gray-400">Потери Черных</span>
                <span id="loss-b" class="text-red-400 font-bold text-lg">0</span>
            </div>
        </div>
        <div id="log" class="flex-1 bg-black p-3 font-mono text-[10px] text-green-500 overflow-y-auto border border-gray-800 rounded min-h-[100px] leading-relaxed">
            <div>> Система готова. Введите IP сервера.</div>
        </div>
        <button onclick="location.reload()" class="btn mt-4 bg-slate-800">Перезагрузка</button>
        <button onclick="toggleAI()" class="btn bg-purple-700 mt-2">ИГРАТЬ С ИИ</button>

    </div>

    <div class="flex-1 flex items-center justify-center bg-[#000000] p-4 relative overflow-hidden">
        <div class="absolute inset-0 opacity-10 bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-blue-900 via-gray-900 to-black pointer-events-none"></div>
        <div id="board" class="board-wrapper shadow-2xl relative z-10">
            <!-- SVG для рисования линии -->
            <svg id="svg-overlay" width="100%" height="100%"></svg>
        </div>
    </div>

    <div id="end-modal" class="modal">
        <div class="bg-gray-900 p-8 border border-gray-700 text-center rounded-xl shadow-2xl max-w-md w-full">
            <h2 id="end-title" class="text-4xl title-font font-bold mb-6 text-white tracking-wider">МАТ</h2>
            <p id="end-desc" class="text-gray-400 text-sm mb-6">Игра окончена.</p>
            <!-- Блок кнопок, который мы будем скрывать для победителя -->
            <div id="end-buttons" class="flex flex-col gap-3">
                <button onclick="activateNewMode()" id="btn-new-mode" class="btn btn-primary py-4 text-lg shadow-lg shadow-blue-900/50">
                    <i class="fas fa-skull mr-2"></i> ВОСКРЕСИТЬ АРМИЮ
                </button>
                <button onclick="initGame()" id="btn-restart" class="btn">Новая Игра</button>
            </div>
            <!-- Сообщение для победителя -->
            <div id="winner-wait-msg" class="hidden text-emerald-400 font-mono animate-pulse">
                ОЖИДАНИЕ РЕШЕНИЯ СОПЕРНИКА...
            </div>
        </div>
    </div>

    <div id="dip-modal" class="modal">
        <div class="bg-slate-800 p-6 border-2 border-purple-500 text-center rounded-xl shadow-[0_0_50px_rgba(168,85,247,0.4)] max-w-sm">
            <h3 class="text-2xl font-bold text-purple-400 mb-2">ПРЕДЛОЖЕНИЕ СОЮЗА</h3>
            <p class="text-gray-300 text-sm mb-6">Вражеский конь предлагает слияние в Химеру.<br><span class="text-red-400 font-bold">Отказ приведет к битве.</span></p>
            <div class="flex gap-4">
                <button onclick="acceptProp()" class="btn bg-purple-600 hover:bg-purple-500 border-none">ПРИНЯТЬ</button>
                <button onclick="declineProp()" class="btn bg-red-600 hover:bg-red-500 border-none">ОТКАЗАТЬ</button>
            </div>
        </div>
    </div>

    <script>
        const GP = { k:'♔', q:'♕', r:'♖', b:'♗', n:'♘', p:'♙', a:'♖', c:'♖', h:'♞', x:'♞', z:'♕', K:'♚', Q:'♛', R:'♜', B:'♝', N:'♞', P:'♟', A:'♜', C:'♜', H:'♘', X:'♘', Z:'♛' };
        
        let board=[], turn='white', selected=null, moves=[], gameMode='classic';
        let kingDead=false, loyalty=3, pendingMove=null;
        let newModePlayer = null;
        let whiteRevived = false;
        let blackRevived = false;
        let moveCount = 0;
        let lastMoveData = null; // Для отрисовки линии
        let aiEnabled = false;  // режим игры против ИИ
        let aiColor = 'black';  // за кого будет играть ИИ

        
        let castling = {
            white: { k: true, l: true, r: true },
            black: { k: true, l: true, r: true }
        };
        function updateLossCounters() {
            // Стоимость фигур в пешках
            const pieceValue = {
                p: 1, P: 1,        // пешки
                n: 3, N: 3,        // кони
                b: 3, B: 3,        // слоны
                r: 5, R: 5,        // ладьи
                a: 8, A: 8,        // архонты/канцлеры светлый
                c: 8, C: 8,        // архонты/канцлеры тёмный
                h: 6, H: 6,        // легион
                q: 10, Q: 10       // ферзь
                // Химеру X/x не указываем → потери не считаются
            };

            // Стартовая стоимость армии (в пешках)
            const START_VALUE =
                8 * 1 +   // пешки
                2 * 3 +   // кони
                2 * 3 +   // слоны
                2 * 5 +   // ладьи
                1 * 10;   // ферзь
            // Король = 0

            let whiteCurrent = 0;
            let blackCurrent = 0;

            // Подсчитываем текущую стоимость армии
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (!p) continue;

                    if (!pieceValue[p]) continue; // игнорируем короля и химеру

                    if (p === p.toUpperCase()) blackCurrent += pieceValue[p];
                    else whiteCurrent += pieceValue[p];
                }
            }

            // Потери = стартовая стоимость - текущая
            const whiteLoss = START_VALUE - whiteCurrent;
            const blackLoss = START_VALUE - blackCurrent;

            document.getElementById('loss-w').innerText = whiteLoss;
            document.getElementById('loss-b').innerText = blackLoss;
        }
        function updateMoraleUI() {
            document.getElementById("morale-w").innerText = whiteMorale.toFixed(1);
            document.getElementById("morale-b").innerText = blackMorale.toFixed(1);

            // цвет меняем в зависимости от состояния
            const wElem = document.getElementById("morale-w");
            const bElem = document.getElementById("morale-b");

            const colorize = (el, morale) => {
                if (morale > 6) el.style.color = "#34d399";      // зелёный — армия уверена
                else if (morale > 3) el.style.color = "#fbbf24"; // жёлтый — тревога
                else el.style.color = "#f87171";                 // красный — паника
            };

            colorize(wElem, whiteMorale);
            colorize(bElem, blackMorale);
        }

        function toggleAI() {
            aiEnabled = !aiEnabled;

            if (aiEnabled) {
                log("Режим ИИ включён. Вы играете против робота.");
                // Отключаем онлайн-режим, если он был активен
                currentRoomId = null;
                myOnlineColor = null;
                isConnected = false;
            } else {
                log("Режим ИИ выключен.");
            }
        }


        function initGame() {
            board = [];
            const r1 = ['r','n','b','q','k','b','n','r'];
            const R1 = ['R','N','B','Q','K','B','N','R'];
            for(let i=0;i<8;i++) {
                if(i===0) board.push([...R1]);
                else if(i===1) board.push(Array(8).fill('P'));
                else if(i===6) board.push(Array(8).fill('p'));
                else if(i===7) board.push([...r1]);
                else board.push(Array(8).fill(null));
            }
            turn='white'; selected=null; moves=[]; gameMode='classic'; kingDead=false;
            loyalty=3; pendingMove=null; newModePlayer=null;
            lastMoveData = null;
            
            castling = { white: { k: true, l: true, r: true }, black: { k: true, l: true, r: true } };
            
            document.getElementById('end-modal').classList.remove('active');
            document.getElementById('dip-modal').classList.remove('active');
            render(); updateUI();
            log("Новая партия началась.");
        }

        const getCol = (p) => { if(!p)return null; return p===p.toUpperCase()?'black':'white'; };
        const getType = (p) => p?p.toLowerCase():null;
        const onBd = (r,c) => r>=0&&r<8&&c>=0&&c<8;
        const isLight = (r,c) => (r+c)%2===0;
        
        function isAttacked(r, c, attackerCol) {
            const tempBoard = board.map(row => [...row]);
            const myCol = attackerCol === 'white' ? 'black' : 'white';
            const oldVal = tempBoard[r][c];
            tempBoard[r][c] = myCol === 'white' ? 'k' : 'K'; 
            const check = inCheck(myCol, tempBoard);
            tempBoard[r][c] = oldVal;
            return check;
        }

        function getMoves(r, c, safe = true) {
            const p = board[r][c];
            if (!p) return [];

            const col = getCol(p), type = getType(p);
            const m = [];

            const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            const kn = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
            const bigKn = [[4,1],[4,-1],[-4,1],[-4,-1],[1,4],[1,-4],[-1,4],[-1,-4]];

            // 1. Pawn
            if (type === 'p') {
                const d = col === 'white' ? -1 : 1;
                const start = col === 'white' ? 6 : 1;

                if (onBd(r+d, c) && !board[r+d][c]) {
                    m.push({r: r+d, c});
                    if (r === start && !board[r+d*2][c]) m.push({r: r+d*2, c});
                }
                [[d,1],[d,-1]].forEach(([dr,dc]) => {
                    if (onBd(r+dr, c+dc)) {
                        const t = board[r+dr][c+dc];
                        if (!safe || (t && getCol(t) !== col))
                            m.push({r:r+dr, c:c+dc, atk:true});
                    }
                });
            }

            // 2. Sliding Pieces (Rook, Bishop, Queen, Archon)
            if (['r','b','q','a','c'].includes(type)) {
                let myDirs = [];
                if (type === 'r' || type === 'q') myDirs.push(...dirs.slice(0,4));
                if (type === 'b' || type === 'q') myDirs.push(...dirs.slice(4));

                if (type === 'a' || type === 'c') {
                    myDirs = [...dirs.slice(0,4)];
                    const okDiag = (type==='a' && isLight(r,c)) || (type==='c' && !isLight(r,c));
                    if (okDiag) myDirs.push(...dirs.slice(4));
                }

                myDirs.forEach(([dr,dc]) => {
                    let tr = r + dr, tc = c + dc;
                    while (onBd(tr,tc)) {
                        const t = board[tr][tc];
                        if (t && getCol(t) === col) {
                            if (type === 'r' && getType(t) === 'b') m.push({ r: tr, c: tc, fuse: true });
                            if (type === 'b' && getType(t) === 'r') m.push({ r: tr, c: tc, fuse: true });
                        }
                        if (!t) { m.push({ r: tr, c: tc }); }
                        else { if (getCol(t) !== col) m.push({ r: tr, c: tc, atk: true }); break; }
                        tr += dr; tc += dc;
                    }
                });
            }

            // 3. Knights, Legion, Chimera
            if (['n','h','x'].includes(type)) {
                const col = getCol(p);  
                function addKnightMove(r2, c2) {
                    if (!onBd(r2,c2)) return;
                    const t = board[r2][c2];
                    if (type === 'n' && t && getType(t)==='n' && getCol(t)!==col) {
                        m.push({ r:r2, c:c2, atk:true, prop:"chimera" });
                        return;
                    }
                    if (!t || getCol(t) !== col) { m.push({ r:r2, c:c2, atk:!!t }); }
                    if (type === 'n' && t && getCol(t)===col && getType(t)==='n') { m.push({ r:r2, c:c2, merge:true }); }
                }
                if (type === 'n' || type === 'x') { for (const [dr,dc] of kn) addKnightMove(r+dr, c+dc); }
                if (type === 'h' || type === 'x') { for (const [dr,dc] of bigKn) addKnightMove(r+dr, c+dc); }
            }

            // 4. King AND New "Heavy Queen" (z)
            if (type === 'k' || type === 'z') {
                dirs.forEach(([dr,dc]) => {
                    if (onBd(r+dr,c+dc)) {
                        const t = board[r+dr][c+dc];
                        if (!t || getCol(t) !== col)
                            m.push({r:r+dr,c:c+dc, atk:!!t});
                    }
                });
                
                if (safe && type === 'k') {
                    const row = (col === 'white' ? 7 : 0);
                    if (!inCheck(col, board)) {
                        const opp = (col === 'white') ? 'black' : 'white';
                        // Short
                        const rookShort = board[row][7];
                        if (castling[col].k && castling[col].r && rookShort && getType(rookShort) === 'r' && getCol(rookShort) === col) {
                            if (!board[row][5] && !board[row][6] && !isAttacked(row, 5, opp) && !isAttacked(row, 6, opp)) {
                                m.push({ r: row, c: 6, castle: "short" });
                            }
                        }
                        // Long
                        const rookLong = board[row][0];
                        if (castling[col].k && castling[col].l && rookLong && getType(rookLong) === 'r' && getCol(rookLong) === col) {
                            if (!board[row][1] && !board[row][2] && !board[row][3] && !isAttacked(row, 3, opp) && !isAttacked(row, 2, opp)) {
                                m.push({ r: row, c: 2, castle: "long" });
                            }
                        }
                    }
                }
            }

            const finalMoves = [];
            for (let mv of m) {
                const targetP = board[mv.r][mv.c];
                if (targetP) {
                    const tType = getType(targetP);
                    const tCol = getCol(targetP);
                    if (tType === 'k') continue; 
                    if (gameMode === 'new_mode' && tType === 'z' && tCol === newModePlayer) continue;
                }
                finalMoves.push(mv);
            }

            if (!safe) return finalMoves;

            const legal = [];
            for (const mv of finalMoves) {
                const tmp = board.map(row => [...row]);
                tmp[mv.r][mv.c] = tmp[r][c];
                tmp[r][c] = null;
                if (!inCheck(col, tmp)) legal.push(mv);
            }
            return legal;
        }

        function inCheck(col, bd) {
            let kr = -1, kc = -1;
            let kingSymbol = (col === 'white') ? 'k' : 'K';

            if (gameMode === 'new_mode' && kingDead && col === newModePlayer) {
                kingSymbol = (col === 'white') ? 'z' : 'Z';
            }

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (bd[r][c] === kingSymbol) { kr = r; kc = c; }
                }
            }

            if (kr === -1) return true;
            const opp = col === 'white' ? 'black' : 'white';

            // 1. Pawn
            const pawnAttackFromDir = (opp === 'white') ? 1 : -1;
            for (let dc of [-1, 1]) {
                const pr = kr + pawnAttackFromDir, pc = kc + dc;
                if (pr >= 0 && pr < 8 && pc >= 0 && pc < 8) {
                    const p = bd[pr][pc];
                    if (p && getCol(p) === opp && getType(p) === 'p') return true;
                }
            }

            // 2. Knights etc...
            const knightSmall = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
            for (let [dr,dc] of knightSmall) {
                const r = kr + dr, c = kc + dc;
                if (r>=0&&r<8&&c>=0&&c<8) {
                    const p = bd[r][c];
                    if (p && getCol(p)===opp && getType(p)==='n') return true;
                }
            }
            const knightLarge = [[4,1],[4,-1],[-4,1],[-4,-1],[1,4],[1,-4],[-1,4],[-1,-4]];
            for (let [dr,dc] of knightLarge) {
                const r = kr + dr, c = kc + dc;
                if (r>=0&&r<8&&c>=0&&c<8) {
                    const p = bd[r][c];
                    if (p && getCol(p)===opp && getType(p)==='h') return true;
                }
            }
            for (let [dr,dc] of [...knightSmall, ...knightLarge]) {
                const r = kr + dr, c = kc + dc;
                if (r>=0&&r<8&&c>=0&&c<8) {
                    const p = bd[r][c];
                    if (p && getCol(p)===opp && getType(p)==='x') return true;
                }
            }

            const rookDirs = [[0,1],[0,-1],[1,0],[-1,0]];
            for (let [dr,dc] of rookDirs) {
                let r=kr+dr, c=kc+dc;
                while (r>=0&&r<8&&c>=0&&c<8) {
                    const p = bd[r][c];
                    if (p) {
                        const t = getType(p);
                        if (getCol(p)===opp && (t==='r' || t==='q' || t==='z' || t==='a' || t==='c')) return true;
                        break;
                    }
                    r+=dr; c+=dc;
                }
            }

            const diagDirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
            for (let [dr,dc] of diagDirs) {
                let r=kr+dr, c=kc+dc;
                while (r>=0&&r<8&&c>=0&&c<8) {
                    const p = bd[r][c];
                    if (p) {
                        const t = getType(p);
                        if (getCol(p)===opp && (t==='b' || t==='q' || t==='z' || t==='a' || t==='c')) return true;
                        break;
                    }
                    r+=dr; c+=dc;
                }
            }

            for (let dr of [-1,0,1]) {
                for (let dc of [-1,0,1]) {
                    if (dr===0 && dc===0) continue;
                    const r = kr + dr, c = kc + dc;
                    if (r>=0&&r<8&&c>=0&&c<8) {
                        const p = bd[r][c];
                        if (p && getCol(p)===opp && getType(p)==='k') return true;
                    }
                }
            }

            return false;
        }

        function checkGameState() {
            let hasMoves = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && getCol(board[r][c]) === turn) {
                        const ms = getMoves(r, c, true).filter(m => !m.fuse && !m.merge && !m.prop);
                        if (ms.length > 0) hasMoves = true;
                    }
                }
            }

            const isCheck = inCheck(turn, board);

            if (!hasMoves && isCheck) {
                // === МАТ ===
                log(`МАТ! Победили ${turn === 'white' ? 'Черные' : 'Белые'}`);
                document.getElementById('end-title').innerText = (turn === 'white' ? "БЕЛЫМ" : "ЧЕРНЫМ") + " МАТ";
                document.getElementById('end-desc').innerText = "Король пал. Возродить армию?";

                const btnMode = document.getElementById('btn-new-mode');
                if (turn === 'white') btnMode.style.display = whiteRevived ? 'none' : 'inline-flex';
                else btnMode.style.display = blackRevived ? 'none' : 'inline-flex';

                const buttonsBlock = document.getElementById('end-buttons');
                const waitMsg = document.getElementById('winner-wait-msg');

                if (window.isOnlineActive() && window.getOnlineColor() && window.getOnlineColor() !== turn) {
                    buttonsBlock.classList.add('hidden');
                    waitMsg.classList.remove('hidden');
                } else {
                    buttonsBlock.classList.remove('hidden');
                    waitMsg.classList.add('hidden');
                }

                document.getElementById('end-modal').classList.add('active');
            }

            else if (!hasMoves && !isCheck) {
                // === ПАТ ===
                log("ПАТ! Ничья.");
                document.getElementById('end-title').innerText = "ПАТ";
                document.getElementById('end-desc').innerText = "Ничья. Ни один игрок не может сделать ход.";
                document.getElementById('btn-new-mode').style.display = 'none';
                document.getElementById('end-buttons').classList.remove('hidden');
                document.getElementById('winner-wait-msg').classList.add('hidden');
                document.getElementById('end-modal').classList.add('active');
            }

            else {
                document.getElementById('end-modal').classList.remove('active');
            }
        }


        function clickCell(r, c) {
            if(window.isOnlineActive() && window.getOnlineColor() && turn!==window.getOnlineColor()) return;
            if(selected) {
                const mv = moves.find(m=>m.r===r && m.c===c);
                if(mv) { doMove(mv); return; }
            }
            if(board[r][c] && getCol(board[r][c])===turn) {
                if(window.isOnlineActive() && window.getOnlineColor() && getCol(board[r][c])!==window.getOnlineColor()) return;
                selected = {r,c}; moves = getMoves(r,c); render();
            } else { selected=null; moves=[]; render(); }
        }

        function doMove(mv) {
            const start = selected;
            const p = board[start.r][start.c];
            const type = getType(p);
            const col = getCol(p);

            // Сохраняем ход для отправки
            const moveDetails = { 
                from: start, 
                to: mv, 
                proposal: !!mv.prop 
            };

            if(mv.prop && window.isOnlineActive()) {
                window.sendMoveToCloud(board, turn, moveDetails, castling, gameMode);
                log("Предложение союза отправлено...");
                selected = null; moves = []; render();
                return; 
            }
            if(mv.prop) { pendingMove = mv; document.getElementById('dip-modal').classList.add('active'); return; }

            if (type === 'k') castling[turn].k = false;
            if (type === 'r') {
                const row = turn==='white'?7:0;
                if (start.r === row && start.c === 0) castling[turn].l = false;
                if (start.r === row && start.c === 7) castling[turn].r = false;
            }
            if (type === 'n') {
                const target = board[mv.r][mv.c];
                if (target && getCol(target) === col && getType(target) === 'n') {
                    board[mv.r][mv.c] = (col === 'white' ? 'h' : 'H');
                    board[start.r][start.c] = null;
                    log("ЛЕГИОН: Объединение завершено.");
                    endTurn(start.r, start.c, mv, moveDetails);
                    return;
                }
                if (type === 'n' && mv.prop === "chimera") {
                    const target = board[mv.r][mv.c];
                    if (target && getType(target)==='n' && getCol(target)!==col) {
                        pendingMove = mv;
                        pendingMove.from = start;
                        pendingMove.to = { r: mv.r, c: mv.c };
                        pendingMove.attackerColor = col;
                        document.getElementById('dip-modal').classList.add('active');
                        log("Предложение: создать ХИМЕРУ");
                        return;
                    }
                }
            }

            if(mv.fuse) {
                const isL = isLight(start.r, start.c); 
                const code = turn==='white'?(isL?'a':'c'):(isL?'A':'C');
                board[mv.r][mv.c] = code;
                board[start.r][start.c] = null;
                log('СЛИЯНИЕ: Канцлер создан.');
            }
            else if(mv.castle) {
                board[mv.r][mv.c] = p;
                board[start.r][start.c] = null;
                castling[turn].k = false; 
                const row = turn==='white'?7:0;
                if (mv.castle === 'short') {
                    board[row][5] = board[row][7]; 
                    board[row][7] = null;
                } else {
                    board[row][3] = board[row][0]; 
                    board[row][0] = null;
                }
                log('РОКИРОВКА!');
            } else {
                board[mv.r][mv.c] = p;
                board[start.r][start.c] = null;
                if(type==='p' && (mv.r===0||mv.r===7)) {
                    if (gameMode === 'new_mode') {
                        board[mv.r][mv.c] = turn==='white'?'q':'Q';
                        log("ПРОМОУШН: Создан Ферзь.");
                    } else {
                        board[mv.r][mv.c] = turn==='white'?'q':'Q';
                    }
                }
            }
            endTurn(start.r, start.c, mv, moveDetails);
        }

        function endTurn(sr, sc, mv, moveDetails) {
            const nextTurn = turn==='white'?'black':'white';


            // Если moveDetails не передан, пытаемся восстановить из sr, sc, mv
            if (!moveDetails && typeof sr !== 'undefined') {
                moveDetails = { from: {r: sr, c: sc}, to: mv };
            }

            if (window.isOnlineActive()) {
                window.sendMoveToCloud(board, nextTurn, moveDetails, castling, gameMode);
            }

            // увеличиваем счетчик ходов
            moveCount++;

            // переворачиваем химеру только раз в два хода
            if (moveCount % 2 === 0) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === 'x') board[r][c] = 'X';
                        else if (board[r][c] === 'X') board[r][c] = 'x';
                    }
                }
            }




            loyalty--;
            if(loyalty<=0) { 
                // Вместо простой проверки запускаем AI
                consultGeminiLoyalty(); 
                loyalty=3; 
            }
            turn = nextTurn;
            selected=null; moves=[];
            
            // Сохраняем локально последний ход для анимации
            lastMoveData = moveDetails;
            updateLossCounters();

            updateUI(); render();
            updateMoraleUI();
            // --- ХОД ИИ ---
            if (aiEnabled && turn === aiColor) {
                setTimeout(() => {
                    const before = lastMoveData; // запоминаем, сделал ли ИИ ход

                    makeAIMove();

                    // если ИИ НЕ сделал ход (например, мат или нет ходов)
                    // lastMoveData осталось прежним → вызываем проверку состояния
                    setTimeout(() => {
                        if (before === lastMoveData) {
                            checkGameState();
                        }
                    }, 50);

                }, 150);

                return; // важный return
            }

            // если ход НЕ ИИ → обычная проверка
            checkGameState();


        }

        let whiteMorale = 10;
        let blackMorale = 10;

        function consultGeminiLoyalty() {

            const whiteLoss = parseInt(document.getElementById("loss-w").innerText);
            const blackLoss = parseInt(document.getElementById("loss-b").innerText);

            // более чувствительная мораль
            whiteMorale = Math.max(0, 10 - whiteLoss / 3);
            blackMorale = Math.max(0, 10 - blackLoss / 3);

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {

                    const p = board[r][c];
                    if (!p || getType(p) !== 'p') continue;

                    const color = getCol(p);
                    const morale = (color === "white") ? whiteMorale : blackMorale;

                    if (morale > 3) continue;

                    let chance = 0;

                    if (morale <= 3) chance = 0.05 + Math.random() * 0.10;   // 5–15%
                    if (morale <= 1) chance = 0.20 + Math.random() * 0.10;   // 20–30%

                    // ПРОВЕРКА ВСЕХ 8 соседних клеток
                    let enemyNearby = false;
                    const dirs = [
                        [1, 0], [-1, 0], [0, 1], [0, -1],
                        [1, 1], [1, -1], [-1, 1], [-1, -1]
                    ];

                    for (let [dr, dc] of dirs) {
                        const rr = r + dr, cc = c + dc;
                        if (!onBd(rr, cc)) continue;
                        const enemy = board[rr][cc];
                        if (enemy && getCol(enemy) !== color) {
                            enemyNearby = true;
                            break;
                        }
                    }

                    if (!enemyNearby) continue;

                    // Измена
                    if (Math.random() < chance) {
                        board[r][c] = (color === "white") ? "P" : "p";
                        log(`⚠ Пешка на (${r},${c}) изменила сторону!`);
                    }
                }
            }
            updateMoraleUI();

            render();
        }



        function checkLoyaltyLocal(wLoss, bLoss) {
            const lossDiff = wLoss - bLoss;
            for(let r=0;r<8;r++)for(let c=0;c<8;c++){
                const p = board[r][c];
                if(p && getType(p)==='p') {
                    // Простейшая проверка на "изоляцию" (нет соседей по бокам)
                    let isolated = true;
                    for (let dc of [-1, 1]) {
                        if (onBd(r, c+dc) && board[r][c+dc] && getCol(board[r][c+dc]) === getCol(p)) isolated = false;
                    }

                    let chance = 0.1;
                    if (isolated) chance += 0.2;

                    if(getCol(p)==='white' && lossDiff >= 2 && Math.random() < chance) {
                        board[r][c] = 'P'; log('ИЗМЕНА! Белая пешка перешла к черным.');
                    }
                    if(getCol(p)==='black' && lossDiff <= -2 && Math.random() < chance) {
                        board[r][c] = 'p'; log('ИЗМЕНА! Черная пешка перешла к белым.');
                    }
                }
            }
        }

        window.activateNewMode = () => {
            const player = turn;

            // Запоминаем, что сторона использовала своё воскрешение
            if (player === 'white') whiteRevived = true;
            else blackRevived = true;

            // старое поведение
            gameMode = 'new_mode';
            newModePlayer = player;
            kingDead = true;

            document.getElementById('end-modal').classList.remove('active');
            
            let legions=0, archons=0;
            for(let r=0;r<8;r++)for(let c=0;c<8;c++){
                const p=board[r][c];
                if(p && getCol(p)===player) {
                    if(['h','x'].includes(getType(p))) legions++;
                    if(['a','c'].includes(getType(p))) archons++;
                }
            }
            for(let r=0;r<8;r++)for(let c=0;c<8;c++) if(board[r][c]&&getCol(board[r][c])===player) board[r][c]=null;
            
            const baseR = player==='white'?7:0, pawnR = player==='white'?6:1;
            const r1 = player==='white'?['r','n','b','q','k','b','n','r']:['R','N','B','Q','K','B','N','R'];
            board[baseR] = [...r1]; board[pawnR] = Array(8).fill(player==='white'?'p':'P');
            
            for(let c=0;c<8;c++){
                const p = board[baseR][c];
                if(getType(p)==='n' && legions>0) { board[baseR][c]=player==='white'?'h':'H'; legions--; }
                if(getType(p)==='r' && archons>0) { 
                    const isL = isLight(baseR, c);
                    board[baseR][c]=player==='white'?(isL?'a':'c'):(isL?'A':'C'); 
                    archons--; 
                }
            }
            board[baseR][4] = null; 
            board[baseR][3] = player==='white'?'z':'Z';

            log("НОВЫЙ РЕЖИМ! Король мертв. Ферзь (Z) — Лидер.");
            
            if(window.isOnlineActive()) window.sendMoveToCloud(board, turn, {}, castling, gameMode);
            render();
        };

        window.acceptProp = () => {
            document.getElementById('dip-modal').classList.remove('active');
            const code = turn==='white'?'x':'X';
            board[pendingMove.r][pendingMove.c] = code;
            board[selected.r][selected.c] = null;
            log('ХИМЕРА создана.'); 
            endTurn(selected.r, selected.c, pendingMove); 
            pendingMove=null;
        };
        window.declineProp = () => {
            document.getElementById('dip-modal').classList.remove('active');
            board[pendingMove.r][pendingMove.c] = board[selected.r][selected.c]; 
            board[selected.r][selected.c] = null;
            log('ОТКАЗ. Враг уничтожен.'); 
            endTurn(selected.r, selected.c, pendingMove); 
            pendingMove=null;
        };

        // === ОБНОВЛЕННЫЙ RENDER С АНИМАЦИЕЙ И ЛИНИЯМИ ===
        function render() {
            const div = document.getElementById('board'); 
            const svg = document.getElementById('svg-overlay');
            
            // Очищаем только клетки, SVG оставляем (но очищаем его контент внутри)
            // Чтобы не удалять сам SVG элемент, очищаем div.innerHTML, но потом восстанавливаем SVG?
            // Проще: удаляем все div.cell, оставляем svg
            const cells = div.querySelectorAll('.cell');
            cells.forEach(c => c.remove());
            svg.innerHTML = ''; // Очищаем линии

            let inChk = inCheck(turn, board);

            // Логика поворота через CSS
            const wrapper = document.querySelector('.board-wrapper');
            const isFlipped = (myOnlineColor === 'black');
            
            if (isFlipped) wrapper.classList.add('flipped');
            else wrapper.classList.remove('flipped');

            // Рисуем клетки всегда в стандартном порядке (0..7), поворот делает CSS
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const d = document.createElement('div');
                    d.className = `cell ${(r+c)%2?'dark':'light'}`;
                    if(selected && selected.r===r && selected.c===c) d.classList.add('selected');
                    
                    const p = board[r][c];
                    if(inChk && p && getCol(p)===turn) {
                        const target = (gameMode==='new_mode'&&kingDead&&turn===newModePlayer)?'z':'k';
                        if(getType(p)===target) d.classList.add('check');
                    }

                    if(p) {
                        const s = document.createElement('span');
                        s.className = `piece ${getCol(p)}`;
                        const t = getType(p);
                        if (t === 'a' || t === 'c') {
                            s.classList.add('archon');
                            if (t === 'a') s.classList.add('archon-light'); else s.classList.add('archon-dark');
                            s.innerHTML += `<span class="badge">${t === 'a' ? 'A' : 'C'}</span>`;
                        }
                        if(t==='h') { s.classList.add('legion'); s.innerHTML += `<span class="badge">L</span>`; }
                        if(t==='x') { s.classList.add('chimera'); s.innerHTML += `<span class="badge">X</span>`; }
                        if(t==='z') { s.classList.add('heavy'); s.innerHTML += `<span class="badge">Z</span>`; }

                        s.innerText = GP[p] || GP[getType(p)==='z' ? (getCol(p)==='white'?'q':'Q') : p] || p;
                        d.appendChild(s);
                    }
                    
                    const mv = moves.find(m=>m.r===r && m.c===c);
                    if(mv) {
                        const h = document.createElement('div'); h.className='hint';
                        if(mv.prop) h.classList.add('union-hint');
                        else if(mv.atk) h.classList.add('attack-hint');
                        else if(mv.fuse) { h.classList.add('special-hint','fuse'); h.innerText='FUSE'; }
                        else if(mv.merge) { h.classList.add('special-hint','legion'); h.innerText='LEGION'; }
                        else if(mv.castle) { h.classList.add('special-hint','castle'); h.innerText='CASTLE'; }
                        else h.classList.add('move-hint');
                        d.appendChild(h);
                    }
                    d.onclick = () => clickCell(r,c);
                    div.appendChild(d);
                }
            }
            ;

            // === ОТРИСОВКА ЛИНИИ ПОСЛЕДНЕГО ХОДА ===
            if (lastMoveData && lastMoveData.from && lastMoveData.to) {
                // ИСПРАВЛЕННАЯ ССЫЛКА НА ПРОСТРАНСТВО ИМЕН SVG
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.classList.add("last-move-purple");


                // Координаты центров клеток (в процентах)
                // Ширина клетки = 12.5%, Центр = 6.25%
                const x1 = (lastMoveData.from.c * 12.5 + 6.25) + '%';
                const y1 = (lastMoveData.from.r * 12.5 + 6.25) + '%';
                const x2 = (lastMoveData.to.c * 12.5 + 6.25) + '%';
                const y2 = (lastMoveData.to.r * 12.5 + 6.25) + '%';

                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', 'rgba(124, 58, 237, 0.5)'); // Полупрозрачный фиолетовый
                line.setAttribute('stroke-width', '6');
                line.setAttribute('stroke-linecap', 'round');
                
                svg.appendChild(line);
            }
        }

        function updateUI() { 
            document.getElementById('turn-display').innerText = turn.toUpperCase(); 
            document.getElementById('mode-display').innerText = gameMode==='new_mode'?'LAST STAND':'КЛАССИКА';
            document.getElementById('loyalty').innerText = loyalty;
        }
        function log(t) { const l = document.getElementById('log'); l.innerHTML = `<div>> ${t}</div>` + l.innerHTML; }

        window.getBoardState = () => board;
        window.syncBoardFromOnline = (newBoard, newTurn, newCastling) => {
            if (JSON.stringify(board) === JSON.stringify(newBoard) && turn === newTurn) return;
            board = newBoard; turn = newTurn; 
            if(newCastling) castling = newCastling;
            selected = null; moves = [];
            render(); updateUI(); checkGameState();
        };
        function evaluateBoard(board, color) {
            let score = 0;

            // Базовая стоимость фигур
            const values = {
                p: 1, n: 3, b: 3, r: 5, q: 9,
                h: 5, a: 7, c: 7, x: 7, z: 10,
                k: 1000
            };

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (!p) continue;

                    const type = p.toLowerCase();
                    let v = values[type] || 0;

                    // Материал
                    if (getCol(p) === color) score += v;
                    else score -= v;

                    // Центр
                    if ([3, 4].includes(r) && [3, 4].includes(c)) {
                        if (getCol(p) === color) score += 0.3;
                        else score -= 0.3;
                    }

                    // Активность (для лёгких фигур)
                    if (['n', 'b', 'h', 'x'].includes(type)) {
                        if (getCol(p) === color) score += 0.1;
                    }
                }
            }

            return score;
        }

        // Оценка конкретного хода
        function evaluateMove(from, mv, board, color) {
            let score = 0;

            const piece = board[from.r][from.c];
            const target = board[mv.r][mv.c];

            // 1: мат / шах
            const testBoard = simulateMove(board, from, mv);
            if (inCheck(opposite(color), testBoard)) score += 20;

            // 2: взятие (материал)
            if (target) {
                score += getPieceValue(target) * 1.2;
            }

            // 3: безопасность (не подставляемся)
            const after = simulateMove(board, from, mv);
            if (inCheck(color, after)) score -= 10;

            // 4: выход из угла / развитие
            if (piece.toLowerCase() === 'n' || piece.toLowerCase() === 'b') {
                if (from.r === 7 && color === 'black') score += 0.5;
                if (from.c === 7 && color === 'black') score += 0.3;
            }

            // 5: контроль центра
            if ([3, 4].includes(mv.r) && [3, 4].includes(mv.c)) score += 0.4;

            // 6: штраф за повторные ходы (туда-сюда)
            if (lastMoveData &&
                lastMoveData.from &&
                lastMoveData.to &&
                lastMoveData.from.r === mv.r &&
                lastMoveData.from.c === mv.c &&
                lastMoveData.to.r === from.r &&
                lastMoveData.to.c === from.c) {
                score -= 2;
            }

            return score;
        }

        // НОВЫЙ ИИ (уровень B)
        function makeAIMove() {
            if (!aiEnabled) return;
            if (window.isOnlineActive()) return;
            if (pendingMove) {
                declineProp();
                return;
            }

            let bestScore = -9999;
            let bestMove = null;

            // Перебор всех фигур чёрных
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && getCol(board[r][c]) === aiColor) {
                        let mvList = getMoves(r, c, true).filter(m => !m.prop && !m.merge && !m.fuse);

                        for (let mv of mvList) {
                            let score = evaluateMove({ r, c }, mv, board, aiColor);

                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = { from: { r, c }, to: mv };
                            }
                        }
                    }
                }
            }

            if (!bestMove) {
                // нет ходов
                return;
            }

            executeAImove(bestMove);
        }


        function getPieceValue(p) {
            if (!p) return 0;
            p = p.toLowerCase();
            return {
                'p': 1,
                'n': 3,
                'h': 5,
                'b': 3,
                'r': 5,
                'a': 7,
                'c': 7,
                'q': 9,
                'x': 7,
                'z': 10,
                'k': 100
            }[p] || 0;
        }

        function opposite(col) {
            return col === 'white' ? 'black' : 'white';
        }

        function simulateMove(bd, from, to) {
            let copy = bd.map(row => [...row]);
            copy[to.r][to.c] = copy[from.r][from.c];
            copy[from.r][from.c] = null;
            return copy;
        }

        function executeAImove(move) {
            selected = move.from;
            doMove(move.to);
            selected = null;
        }


        initGame();
    </script>
</body>
</html>
